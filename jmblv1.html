<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content"
  />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>JUMBL</title>
  <style>
    /* ------------------------------------------------------
       0) Base / Theme / Resets — flat, monochrome, no shadows
       ------------------------------------------------------ */
    :root{
      color-scheme: light dark; /* keep system UI in sync */
      /* Light (default) */
      --bg:#FFFFFF; --fg:#000000; --muted:rgba(0,0,0,.60); --track:rgba(0,0,0,.12);
      --tile-bg:#FFFFFF; --tile-fg:#000000; --btn-bg:#FFFFFF; --btn-fg:#000000;
      --border:rgba(0,0,0,.15); --radius:12px;
      /* layout clamps */
      --maxw:600px; /* app max width */
      --gap:10px;   /* tile/bank gap */
      --stack-tight: clamp(6px, 1.3vh, 12px);
    }
    .dark{
      /* Dark override */
      --bg:#000000; --fg:#FFFFFF; --muted:rgba(255,255,255,.65); --track:rgba(255,255,255,.15);
      --tile-bg:#000000; --tile-fg:#FFFFFF; --btn-bg:#000000; --btn-fg:#FFFFFF;
      --border:rgba(255,255,255,.18);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font: 500 16px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:var(--bg); color:var(--fg);
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    }

    /* Prevent accidental selection/zoom inside the app */
    #app{
      min-height:100dvh; min-height:100vh;
      padding:
        calc(env(safe-area-inset-top) + 14px)
        14px
        calc(env(safe-area-inset-bottom) + 14px);
      max-width:var(--maxw); margin:0 auto;
      display:grid; gap:var(--stack-tight);
      grid-template-rows:
        auto            /* header */
        auto            /* status (lives/score) */
        auto            /* timer */
        auto            /* answer row */
        auto            /* bank row */
        auto            /* controls */
        1fr             /* spacer */
        auto;           /* theme btn */
      touch-action: manipulation;
      user-select:none; -webkit-user-select:none;
      overscroll-behavior:none;
    }

    /* Header */
    .head{
      display:flex; align-items:center; justify-content:space-between;
    }
    .title{
      font-weight:800; letter-spacing:.08em; font-size: clamp(20px, 3.8vw, 28px);
    }

    /* Status row */
    .status{
      display:flex; align-items:center; justify-content:space-between;
    }
    .lives{
      display:flex; gap:8px;
    }
    .pip{
      width:14px; height:14px; border-radius:4px;
      border:1px solid var(--border); background: currentColor; color: var(--fg);
    }
    .pip.off{
      background: transparent; color: var(--track);
    }
    .score{
      font-weight:600; opacity:.9; font-size: clamp(14px, 2.9vw, 16px);
    }

    /* Timer */
    .timer-card{
      border:1px solid var(--border); border-radius: var(--radius);
      padding:8px 10px;
    }
    .timer-rail{
      position:relative; height:10px; border-radius:999px; background:var(--track);
      overflow:hidden;
    }
    .timer-fill{
      position:absolute; inset:0 0 0 0; transform-origin:left center;
      transform:scaleX(1);
      background: currentColor; color: var(--fg);
    }
    .timer-meta{
      margin-top:8px; display:flex; align-items:center; justify-content:space-between;
      font-size:14px; color:var(--muted);
    }

    /* Tiles (answer row) */
    .answer{
      display:grid; grid-template-columns: repeat(5, 1fr); gap: var(--gap);
    }
    .tile{
      display:grid; place-items:center;
      aspect-ratio:1/1; border-radius: var(--radius);
      border:1px solid var(--border);
      background:var(--tile-bg); color:var(--tile-fg);
      font-weight:800; font-size: clamp(22px, 8.2vw, 44px);
      text-transform:uppercase;
    }
    .tile.empty{ opacity:.45 }

    /* Bank */
    .bank{
      display:grid; grid-template-columns: repeat(5, 1fr); gap: var(--gap);
    }
    .btn-letter{
      display:grid; place-items:center;
      height: clamp(52px, 11.2vw, 76px);
      border-radius: var(--radius);
      border:1px solid var(--border);
      background:var(--btn-bg); color:var(--btn-fg);
      font-weight:800; font-size: clamp(20px, 7vw, 38px);
      text-transform:uppercase;
      transition: transform .06s ease;
    }
    .btn-letter:disabled{ opacity:.35 }
    .press{ transform: scale(.96) }

    /* Controls */
    .controls{
      display:grid; grid-template-columns: 1fr 1fr; gap: var(--gap);
    }
    .btn{
      height: 52px; border-radius: var(--radius);
      border:1px solid var(--border);
      background:var(--btn-bg); color:var(--btn-fg);
      font-weight:700; font-size:16px;
      transition: transform .06s ease;
    }
    .btn.press{ transform: scale(.98) }

    /* Theme button (bottom-right) */
    .theme-wrap{ display:flex; justify-content:flex-end; }
    .theme{
      width:44px; height:44px; border-radius:50%;
      display:grid; place-items:center;
      border:1px solid var(--border); background:var(--btn-bg); color:var(--btn-fg);
    }
    .theme svg{ width:24px; height:24px; display:block }

    /* Modal */
    .overlay{
      position:fixed; inset:0; background:rgba(0,0,0,.5);
      display:none;
    }
    .overlay[aria-hidden="false"]{ display:block; }
    .dialog{
      position:fixed; inset:0; display:grid; place-items:center;
      padding: 20px;
      pointer-events:none;
    }
    .dialog[aria-hidden="false"]{ pointer-events:auto; }
    .panel{
      width: min(480px, calc(100vw - 28px));
      background:var(--bg); color:var(--fg);
      border:1px solid var(--border); border-radius: var(--radius);
      padding: 18px;
      box-shadow: none;
    }
    .panel h2{ margin:0 0 8px 0; font-size:20px }
    .panel .body{ color: var(--fg); opacity:.9; line-height:1.35 }
    .panel .actions{ margin-top:16px; display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap }
    .panel .actions button{
      border:1px solid var(--border); border-radius:12px; padding:10px 14px;
      background:var(--btn-bg); color:var(--btn-fg); font-weight:700;
    }

    /* A11y helpers */
    .sr-only{ position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden }

    /* Animations */
    @keyframes shake{ 0%,100%{transform:translateX(0)} 20%{transform:translateX(-6px)} 60%{transform:translateX(6px)} }
    @keyframes shakeSoft{ 0%,100%{transform:translateX(0)} 25%{transform:translateX(-2px)} 75%{transform:translateX(2px)} }
    @keyframes jiggle{ 0%,100%{transform:rotate(0)} 25%{transform:rotate(-1deg)} 75%{transform:rotate(1deg)} }
    @keyframes pop{ 0%{transform:scale(1)} 30%{transform:scale(1.08)} 100%{transform:scale(1)} }
    .shake{ animation:shake .32s ease }
    .shake-soft{ animation:shakeSoft .32s ease }
    .jiggle{ animation:jiggle .28s ease }
    .pop{ animation:pop .28s ease }
    .pop-soft{ animation:pop .18s ease }
  </style>
</head>
<body>
  <main id="app" aria-label="JUMBL word game">
    <header class="head">
      <div class="title" aria-label="Game title">JUMBL</div>
    </header>

    <section class="status" aria-label="Status">
      <div id="lives" class="lives" aria-label="Lives"></div>
      <div id="score" class="score" aria-live="polite">Score: 0</div>
    </section>

    <section class="timer-card" aria-label="Timer">
      <div class="timer-rail" aria-hidden="true">
        <div id="timerFill" class="timer-fill"></div>
      </div>
      <div class="timer-meta">
        <div id="timerLabel">00:25</div>
        <div class="sr-only" id="sr-seconds" aria-live="polite"></div>
        <div class="muted">Beat the clock</div>
      </div>
    </section>

    <section class="answer" id="answerRow" aria-label="Answer row (fill left to right)"></section>
    <section class="bank" id="bankRow" aria-label="Letter bank"></section>

    <section class="controls" aria-label="Controls">
      <button id="shuffleBtn" class="btn" type="button" aria-label="Shuffle letters">Shuffle</button>
      <button id="clearBtn"   class="btn" type="button" aria-label="Clear all">Clear</button>
    </section>

    <div class="theme-wrap">
      <button id="themeBtn" class="theme" type="button" aria-label="Toggle theme">
        <svg id="themeIcon" aria-hidden="true"></svg>
      </button>
    </div>

    <!-- A11y live region for granular messages -->
    <div class="sr-only" id="announcer" aria-live="polite"></div>
  </main>

  <!-- Modal elements -->
  <div id="overlay" class="overlay" aria-hidden="true"></div>
  <div id="dialog" class="dialog" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="dialogTitle">
    <div class="panel">
      <h2 id="dialogTitle">Title</h2>
      <div id="dialogBody" class="body"></div>
      <div id="dialogActions" class="actions"></div>
    </div>
  </div>

  <script>
  (function(){
    /* ------------------------------
       1) Fast DOM helpers
       ------------------------------ */
    const $ = (sel, root=document) => root.querySelector(sel);

    /* ------------------------------
       2) Constants
       ------------------------------ */
    const COUNTDOWN_SECONDS = 25;
    const STARTING_LIVES = 3;
    const TICK_MS = 100;

    /* ------------------------------
       3) State
       ------------------------------ */
    const state = {
      answerWord: "",
      bank: [],                  // [{ch, used}]
      current: ["","","","",""], // answer slots
      placedIndex: [null,null,null,null,null], // which bank index filled each slot
      lives: STARTING_LIVES,
      score: 0,
      runStartAt: 0,
      deadlineAt: 0,
      timerHandle: null,
      isAnimating: false,
      modalOpen: false
    };

    let ANSWER_POOL = [];
    let GUESSES_SET = new Set();

    /* ------------------------------
       4) Grab elements
       ------------------------------ */
    const app = $("#app");
    const livesEl = $("#lives");
    const scoreEl = $("#score");
    const timerFill = $("#timerFill");
    const timerLabel = $("#timerLabel");
    const srSeconds = $("#sr-seconds");
    const answerRow = $("#answerRow");
    const bankRow = $("#bankRow");
    const shuffleBtn = $("#shuffleBtn");
    const clearBtn = $("#clearBtn");
    const themeBtn = $("#themeBtn");
    const overlay = $("#overlay");
    const dialog = $("#dialog");
    const dialogTitle = $("#dialogTitle");
    const dialogBody = $("#dialogBody");
    const dialogActions = $("#dialogActions");
    const announcer = $("#announcer");

    /* ------------------------------
       5) Theme (persist localStorage)
       ------------------------------ */
    const THEME_KEY = 'jumbl-theme';
    function applyTheme(t){ document.documentElement.classList.toggle('dark', t === 'dark'); updateThemeIcon(); }
    function getSystemTheme(){ return matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'; }
    function initTheme(){ applyTheme(localStorage.getItem(THEME_KEY) || getSystemTheme()); }
    function toggleTheme(){
      const isDark = document.documentElement.classList.toggle('dark');
      localStorage.setItem(THEME_KEY, isDark ? 'dark' : 'light');
      updateThemeIcon();
    }
    function updateThemeIcon(){
      const isDark = document.documentElement.classList.contains('dark');
      const svg = $("#themeIcon");
      if(!svg) return;
      svg.setAttribute('viewBox','0 0 24 24');
      if(isDark){
        // filled crescent moon
        svg.innerHTML = '<path fill="currentColor" d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>';
      }else{
        // filled sun disc
        svg.innerHTML = '<circle cx="12" cy="12" r="10" fill="currentColor"/>';
      }
    }
    makeTap(themeBtn, toggleTheme);

    /* ------------------------------
       6) Utilities
       ------------------------------ */
    const randInt = n => Math.floor(Math.random()*n);
    function shuffleInPlace(arr){ for(let i=arr.length-1;i>0;i--){ const j = randInt(i+1); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
    function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

    const ANIM_CLASSES = ['shake','shake-soft','jiggle','pop','pop-soft'];
    function play(el, cls){
      if(!el) return;
      ANIM_CLASSES.forEach(c => el.classList.remove(c));
      // Force reflow to restart CSS animations
      // eslint-disable-next-line no-unused-expressions
      el.offsetHeight;
      el.classList.add(cls);
    }

    function normalizeList(text){
      const out = []; const seen = new Set();
      text.split(/\r?\n/).forEach(line=>{
        const s = line.trim().toUpperCase();
        if(/^[A-Z]{5}$/.test(s) && !seen.has(s)){ seen.add(s); out.push(s); }
      });
      return out;
    }
    function pickAnswer(){ return ANSWER_POOL[randInt(ANSWER_POOL.length)]; }
    function buildBankFrom(word){
      const arr = word.split("").map(ch=>({ ch, used:false }));
      return shuffleInPlace(arr);
    }
    function secondsSince(ts){ return Math.floor((Date.now()-ts)/1000); }
    function fmtMMSS(total){ const m = Math.floor(total/60).toString().padStart(2,'0'); const s = (total%60).toString().padStart(2,'0'); return `${m}:${s}`; }

    /* ------------------------------
       7) Rendering
       ------------------------------ */
    function renderLives(){
      const frag = document.createDocumentFragment();
      for(let i=0;i<STARTING_LIVES;i++){
        const d = document.createElement('div');
        d.className = 'pip' + (i < state.lives ? '' : ' off');
        frag.appendChild(d);
      }
      livesEl.innerHTML = '';
      livesEl.appendChild(frag);
    }
    function renderScore(){ scoreEl.textContent = `Score: ${state.score}`; }
    let lastSpokenSecs = -1;
    function renderTimer(){
      const now = performance.now();
      const msLeft = Math.max(0, state.deadlineAt - now);
      const secs = Math.ceil(msLeft/1000);
      const frac = clamp(msLeft/(COUNTDOWN_SECONDS*1000), 0, 1);
      timerFill.style.transform = `scaleX(${frac})`;
      timerLabel.textContent = fmtMMSS(Math.ceil(msLeft/1000));

      // SR speak at most once per second
      if (secs !== lastSpokenSecs) {
        srSeconds.textContent = `${secs} seconds remaining`;
        lastSpokenSecs = secs;
      }
    }
    function renderAnswer(){
      const frag = document.createDocumentFragment();
      for(let i=0;i<5;i++){
        const v = state.current[i] || '';
        const d = document.createElement('div');
        d.className = 'tile' + (v ? '' : ' empty');
        d.textContent = v;
        d.setAttribute('aria-label', v ? `Slot ${i+1}: ${v}` : `Slot ${i+1}: empty`);
        frag.appendChild(d);
      }
      answerRow.innerHTML = '';
      answerRow.appendChild(frag);
    }
    function renderBank(){
      const frag = document.createDocumentFragment();
      state.bank.forEach((b, idx)=>{
        const btn = document.createElement('button');
        btn.className = 'btn-letter';
        btn.type = 'button';
        btn.textContent = b.ch;
        btn.disabled = b.used;
        btn.setAttribute('aria-pressed', b.used ? 'true' : 'false');
        btn.dataset.idx = String(idx);
        frag.appendChild(btn);
      });
      bankRow.innerHTML = '';
      bankRow.appendChild(frag);
      syncControlHeights();
    }
    function renderUI(){
      renderLives(); renderScore(); renderTimer(); renderAnswer(); renderBank();
    }
    function syncControlHeights(){
      const tile = bankRow.querySelector('.btn-letter');
      const h = tile ? Math.round(tile.getBoundingClientRect().height) : 0;
      if(h){
        shuffleBtn.style.height = h + 'px';
        clearBtn.style.height = h + 'px';
      }
    }

    /* ------------------------------
       8) Timer control
       ------------------------------ */
    function startTimer(){
      stopTimer();
      state.deadlineAt = performance.now() + COUNTDOWN_SECONDS*1000;
      renderTimer();
      state.timerHandle = setInterval(()=>{
        renderTimer();
        if(performance.now() >= state.deadlineAt){ onTimeout(); }
      }, TICK_MS);
    }
    function stopTimer(){ if(state.timerHandle){ clearInterval(state.timerHandle); state.timerHandle = null; } }

    /* ------------------------------
       9) Core game flow
       ------------------------------ */
    function startRun(){
      state.lives = STARTING_LIVES;
      state.score = 0;
      state.runStartAt = Date.now();
      nextWord(false);
    }
    function nextWord(increment){
      if(increment) state.score++;
      state.answerWord = pickAnswer();
      state.bank = buildBankFrom(state.answerWord);
      state.current = ["","","","",""];
      state.placedIndex = [null,null,null,null,null];
      state.isAnimating = false;
      renderUI();
      startTimer();
    }
    function onTimeout(){
      if(state.timerHandle === null) return; // already handled
      stopTimer();
      state.lives = Math.max(0, state.lives - 1);
      renderLives();
      // Reveal the correct word, shake, then advance or game over
      state.isAnimating = true;
      for(let i=0;i<5;i++){ state.current[i] = state.answerWord[i]; }
      renderAnswer();
      play(answerRow, 'shake');
      setTimeout(()=>{
        state.isAnimating = false;
        if(state.lives > 0){ nextWord(false); }
        else{ gameOver(); }
      }, 800);
    }

    /* ------------------------------
       10) Input: letters, clear, shuffle, backspace
       ------------------------------ */
    function onLetterTap(idx){
      if(state.isAnimating || state.modalOpen) return;
      // find first empty slot
      const slot = state.current.findIndex(c => !c);
      if(slot === -1) return;
      const b = state.bank[idx];
      if(!b || b.used) return;

      state.current[slot] = b.ch;
      state.placedIndex[slot] = idx;
      b.used = true;

      renderAnswer(); renderBank();

      const slotEl = answerRow.children[slot];
      if (slotEl) play(slotEl, 'pop-soft');

      autoSubmitIfFull();
    }
    function onShuffle(){
      if(state.isAnimating || state.modalOpen) return;
      // shuffle only unused letters
      const unused = [], unusedIdx = [];
      state.bank.forEach((b, i)=>{ if(!b.used){ unused.push(b); unusedIdx.push(i); } });
      shuffleInPlace(unused);
      unusedIdx.forEach((slot, j)=>{ state.bank[slot] = unused[j]; });
      renderBank();
      play(bankRow, 'jiggle');
    }
    // Remove rightmost placed letter and return it to the bank
    function onBackspace(opts = { animate: true }){
      if (state.isAnimating || state.modalOpen) return;
      // find rightmost non-empty slot
      let i = -1;
      for (let j = 4; j >= 0; j--) { if (state.current[j]) { i = j; break; } }
      if (i === -1) return;

      // restore bank letter that originally filled this slot
      const bi = state.placedIndex[i];
      if (bi !== null) state.bank[bi].used = false;

      state.current[i] = "";
      state.placedIndex[i] = null;

      renderAnswer(); renderBank();

      if (opts.animate){
        const slotEl = answerRow.children[i];
        if (slotEl) play(slotEl, 'shake-soft');
      }
    }

    function onClearAll(opts = { animate: true, force: false }){
      // If a PointerEvent accidentally arrives, fall back to defaults
      if (opts && typeof opts === 'object' && ('type' in opts) && ('pointerId' in opts)) {
        opts = { animate: true, force: false };
      }
      // allow clearing during animations only when explicitly forced
      if (!opts.force && (state.isAnimating || state.modalOpen)) return;

      for (let i = 0; i < 5; i++) {
        const bi = state.placedIndex[i];
        if (bi !== null) { state.bank[bi].used = false; }
        state.current[i] = "";
        state.placedIndex[i] = null;
      }
      renderAnswer(); renderBank();

      if (opts.animate){ play(answerRow, 'shake-soft'); }
    }

    function autoSubmitIfFull(){
      if(state.current.every(c=>c)){
        evaluateGuess(state.current.join(''));
      }
    }
    function evaluateGuess(guess){
      if (GUESSES_SET.has(guess)) {
        // Correct (per spec: any valid 5-letter dictionary word advances)
        stopTimer();
        state.isAnimating = true;
        play(answerRow, 'pop-soft');
        [...answerRow.children].forEach(el => play(el, 'pop'));
        setTimeout(() => {
          state.isAnimating = false;
          nextWord(true);
        }, 600);
        return;
      }

      // Invalid: shake, then clear — robust on older iOS
      state.isAnimating = true;
      play(answerRow, 'shake');

      let cleared = false;
      const finish = () => {
        if (cleared) return;
        cleared = true;
        answerRow.removeEventListener('animationend', finish);
        onClearAll({ animate: false, force: true }); // clear during anim
        state.isAnimating = false;
      };
      // Prefer animationend, but also guard with a timeout
      answerRow.addEventListener('animationend', finish, { once:true });
      setTimeout(finish, 400);
    }

    /* Pointer-driven letter taps (press feedback) */
    bankRow.addEventListener('pointerdown', (e)=>{
      const t = e.target;
      if(!(t instanceof HTMLElement)) return;
      if(!t.classList.contains('btn-letter')) return;
      if (t.disabled) return;
      t.classList.add('press');
      // capture so we always get the matching pointerup/cancel
      if (typeof t.setPointerCapture === 'function') {
        try { t.setPointerCapture(e.pointerId); } catch {}
      }
    });
    bankRow.addEventListener('pointerup', (e)=>{
      const t = e.target;
      if(!(t instanceof HTMLElement)) return;
      if(!t.classList.contains('btn-letter')) return;
      t.classList.remove('press');
      if (t.disabled) return; // might have been disabled mid-press
      const idx = Number(t.dataset.idx);
      onLetterTap(idx);
    });
    bankRow.addEventListener('pointercancel', (e)=>{
      const t = e.target;
      if(t instanceof HTMLElement && t.classList.contains('btn-letter')){
        t.classList.remove('press');
      }
    });
    bankRow.addEventListener('pointerleave', (e)=>{
      const t = e.target;
      if(t instanceof HTMLElement && t.classList.contains('btn-letter')){
        t.classList.remove('press');
      }
    });

    /* Buttons: stay "pressed" while held; pop back on pointerup, then run action */
    function makeTap(btn, handler){
      btn.addEventListener('pointerdown', () => btn.classList.add('press'));
      btn.addEventListener('pointerup',   () => { btn.classList.remove('press'); handler(); });
      btn.addEventListener('pointercancel', () => btn.classList.remove('press'));
      btn.addEventListener('pointerleave',  () => btn.classList.remove('press'));
    }
    makeTap(shuffleBtn, onShuffle);
    makeTap(clearBtn, onClearAll);

    /* Keyboard support (desktop) */
    document.addEventListener('keydown', (e)=>{
      if(state.modalOpen) return;
      if(e.key === 'Backspace'){ e.preventDefault(); onBackspace(); return; }
      if(e.key === 'Enter'){
        if(state.current.every(Boolean)) evaluateGuess(state.current.join(''));
        return;
      }
      const ch = e.key.toUpperCase();
      if(/^[A-Z]$/.test(ch)){
        const i = state.bank.findIndex(b => !b.used && b.ch === ch);
        if(i !== -1){ onLetterTap(i); }
      }
    }, true);

    /* Prevent double-tap zoom on iOS */
    let lastTouchEnd = 0;
    app.addEventListener('touchend', (e)=>{
      const now = Date.now();
      if(now - lastTouchEnd < 350){ e.preventDefault(); }
      lastTouchEnd = now;
    }, { passive:false });

    /* ------------------------------
       11) Modals (reusable) + focus mgmt
       ------------------------------ */
    let restoreFocusEl = null;
    function showModal(title, bodyHTML, actions){
      state.modalOpen = true;
      overlay.setAttribute('aria-hidden','false');
      dialog.setAttribute('aria-hidden','false');
      dialogTitle.textContent = title;
      dialogBody.innerHTML = bodyHTML;
      dialogActions.innerHTML = '';
      (actions || []).forEach(a=>{
        const b = document.createElement('button');
        b.type = 'button';
        b.textContent = a.label;
        if(a.isPrimary) b.autofocus = true;
        makeTap(b, a.action);
        dialogActions.appendChild(b);
      });
      restoreFocusEl = document.activeElement;
      const firstBtn = dialogActions.querySelector('button') || dialog.querySelector('button');
      if(firstBtn) firstBtn.focus();

      // basic trap
      dialog.addEventListener('keydown', trapTab);
      document.addEventListener('keydown', escClose);
    }
    function closeModal(){
      state.modalOpen = false;
      overlay.setAttribute('aria-hidden','true');
      dialog.setAttribute('aria-hidden','true');
      dialogBody.innerHTML = '';
      dialogActions.innerHTML = '';
      dialog.removeEventListener('keydown', trapTab);
      document.removeEventListener('keydown', escClose);
      if(restoreFocusEl && restoreFocusEl instanceof HTMLElement){ restoreFocusEl.focus(); }
    }
    function trapTab(e){
      if(e.key !== 'Tab') return;
      const focusables = dialog.querySelectorAll('button, [href], [tabindex]:not([tabindex="-1"])');
      if(!focusables.length) return;
      const first = focusables[0]; const last = focusables[focusables.length-1];
      if(e.shiftKey && document.activeElement === first){ e.preventDefault(); last.focus(); }
      else if(!e.shiftKey && document.activeElement === last){ e.preventDefault(); first.focus(); }
    }
    function escClose(e){ if(e.key === 'Escape'){ closeModal(); } }

    function showLoading(msg, canRetry){
      const retryBtn = { label:'Retry', action:()=>{ closeModal(); loadWordLists(); }, isPrimary:true };
      showModal('Loading word lists…', `<p>${msg}</p>`, canRetry ? [retryBtn] : []);
    }
    function showIntro(){
      const body = `
        <p>Un-JUMBL the letters to make a 5-letter word.</p>
        <p>Beat the clock to increase your score and refill the timer.</p>
        <p>If the timer hits zero, you lose a life.</p>
        <p><strong>25 seconds</strong> per word • <strong>3 lives</strong></p>
        <p>Highest score wins.</p>`;
      showModal('RULES', body, [ {label:'Play', action:()=>{ closeModal(); startRun(); }, isPrimary:true} ]);
    }
    function showError(title, html){ showModal(title, html, [ {label:'OK', action:()=>closeModal(), isPrimary:true} ]); }
    function gameOver(){
      const body = `
        <p>Your final score is <strong>${state.score}</strong>.</p>
        <p>Play again?</p>`;
      showModal('Game Over', body, [
        { label:'Cancel', action:()=>closeModal() },
        { label:'Play again', action:()=>{ closeModal(); startRun(); }, isPrimary:true }
      ]);
    }

    /* ------------------------------
       12) Data loading & validation
       ------------------------------ */
    async function loadWordLists(){
      showLoading('Fetching…', false);
      try{
        const ctrl = new AbortController();
        const opts = { cache: 'no-store', signal: ctrl.signal };
        const [aRes, gRes] = await Promise.all([
          fetch('answers.txt', opts),
          fetch('guesses.txt', opts)
        ]);
        if(!aRes.ok || !gRes.ok) throw new Error('Network error while fetching lists.');
        const [aText, gText] = await Promise.all([aRes.text(), gRes.text()]);
        const answers = normalizeList(aText);
        const guesses = normalizeList(gText);
        if(!answers.length || !guesses.length) throw new Error('One or both files are empty after parsing.');
        // Build sets and validate subset
        const gSet = new Set(guesses);
        const missing = answers.filter(w => !gSet.has(w));
        if(missing.length){
          showModal(
            'Error in word lists',
            `<p>All answers must also appear in <code>guesses.txt</code>.</p>
             <p>Missing ${missing.length} entries. Example: <code>${missing.slice(0,5).join(', ')}</code></p>`,
            [ {label:'Retry', action:()=>{ closeModal(); loadWordLists(); }, isPrimary:true} ]
          );
          return;
        }
        ANSWER_POOL = answers;
        GUESSES_SET = gSet;
        closeModal();
        showIntro();
      }catch(err){
        showLoading('Could not load files. Check server and try again.', true);
      }
    }

    /* ------------------------------
       13) Wire up
       ------------------------------ */
    makeTap(shuffleBtn, onShuffle);
    makeTap(clearBtn, onClearAll);
    initTheme();
    loadWordLists();
  })();
  </script>
</body>
</html>
