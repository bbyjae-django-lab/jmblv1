<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="utf-8" />
 <meta
   name="viewport"
   content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content"
 />
 <meta name="apple-mobile-web-app-capable" content="yes" />
 <title>JUMBL</title>
 <style>
   /* ------------------------------------------------------
      0) Base / Theme / Resets — flat, monochrome, no shadows
      ------------------------------------------------------ */
   :root{
     color-scheme: light dark; /* keep system UI in sync */
     /* Light (default) */
     --bg:#FFFFFF; --fg:#000000; --muted:rgba(0,0,0,.60); --track:rgba(0,0,0,.12);
     --tile-bg:#FFFFFF; --tile-fg:#000000; --btn-bg:#FFFFFF; --btn-fg:#000000;
     --border:rgba(0,0,0,.15); --radius:12px;


     /* layout clamps */
     --maxw:600px; /* app max width */
     --gap:10px;   /* tile/bank gap */
     --stack-tight: clamp(6px, 1.3vh, 12px);
   }
   html.dark{
     /* Dark */
     --bg:#000000; --fg:#FFFFFF; --muted:rgba(255,255,255,.70); --track:rgba(255,255,255,.15);
     --tile-bg:#000000; --tile-fg:#FFFFFF; --btn-bg:#000000; --btn-fg:#FFFFFF;
     --border:rgba(255,255,255,.20);
   }


   *, *::before, *::after{ box-sizing: border-box; }
   html, body{ height:100%; }
   body{
     margin:0;
     font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
     background:var(--bg);
     color:var(--fg);
     -webkit-text-size-adjust:100%;
     overflow-x:hidden;
   }
   :focus{ outline: auto; }
   :focus:not(:focus-visible){ outline: none; }
   a, button{ -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
   html, body, #app{ touch-action: none; }
   button{
     font:inherit; color:inherit;
     background:var(--btn-bg);
     border:1px solid var(--border);
     border-radius: var(--radius);
     padding:1rem 1rem;
     cursor:pointer;
   }
   button:disabled{ opacity:.35; cursor: default; }


   /* Disable text selection/callouts inside the play area */
   .app, .app *:not(input):not(textarea){
     -webkit-user-select: none; user-select: none; -webkit-touch-callout: none;
   }
   /* Also disable text selection/callouts inside modals */
   .dialog, .dialog *:not(input):not(textarea){
     -webkit-user-select: none; user-select: none; -webkit-touch-callout: none;
   }


   /* ------------------------------
      1) App shell & safe-area insets
      ------------------------------ */
   .app{
     /* Use visualViewport width (via --vw) to avoid iOS rounding bleed */
     width: min(calc(var(--vw, 100vw)), var(--maxw));


     min-height: 100vh;               /* fallback */
     height: 100dvh;                  /* modern browsers */
     margin: 0 auto;
     display:flex; flex-direction:column;


     /* Safe-area aware side padding + base margin */
     padding:
       calc(env(safe-area-inset-top) + 16px)
       max(12px, calc(env(safe-area-inset-right) + 12px))
       calc(env(safe-area-inset-bottom) + 18px)
       max(12px, calc(env(safe-area-inset-left) + 12px));


     overflow: hidden;                /* no scroll bounce */
     overscroll-behavior: none;
     gap: 16px;
   }


   /* Hide all UI except the header during pre-game or while any modal is open */
   .app.pre > :not(.header),
   .app.masked > :not(.header){ display:none !important; }


   /* ------------------------------
      2) Header (3-col grid)
      ------------------------------ */
   .header{ display:grid; grid-template-columns: 1fr 1fr 1fr; align-items:center; }
   .title{ text-align:center; font-weight:900; letter-spacing:.10em; font-size:3.5em; }
   .theme-wrap{ justify-self:end; }
   .icon{ width:28px; height:28px; display:block; } /* was 22px */
   .icon svg{ width:100%; height:100%; display:block; }
   .theme-bottom{ display:flex; justify-content:center; }


   /* ------------------------------
      3) Lives, Score, Timer
      ------------------------------ */
   .lives{ display:flex; justify-content:center; gap:8px; }
   .pip{ width:28px; aspect-ratio:1/1; border:1px solid var(--border); border-radius:6px; background: transparent; }
   .pip.off{ opacity:.32; }
   .lives .pip:not(.off){ background: var(--fg); }


   .score{  text-align:center; font-size:17px; font-weight:700; color:var(--muted); }


   .timer-card{ border:1px solid var(--border); border-radius: var(--radius); padding:10px; }
   .timer-rail{ position:relative; height:14px; border-radius:9999px; background:var(--track); overflow:hidden; }
   .timer-fill{ position:absolute; inset:0; transform-origin:left center; transform: scaleX(1); background:var(--fg); transition: transform 100ms linear; }


   /* spacing tweaks for single-hand reach */
   .header{ margin-top: 36px; margin-bottom: 26px; }
   .lives{  margin-bottom: 4px; }
   .score{  margin-top: 4px; margin-bottom: 4px; }
   .timer-card{ margin-top: 4px; margin-bottom: 2px; }
   .row{ margin-top: 2px; margin-bottom: 2px; }
   .bank{ margin-top: 2px; margin-bottom: 2px; }
   .controls{ margin-top: 2px; margin-bottom: 4px; }
   .theme-bottom{ margin-top: 4px; }


   /* ------------------------------
      4) Squares: Answer row & Letter bank
      ------------------------------ */
   .row, .bank{ display:grid; grid-template-columns: repeat(5, minmax(0, 1fr)); gap: var(--gap); }
   .tile, .btn-letter{
     aspect-ratio:1/1;
     min-inline-size:64px;
     border:1px solid var(--border); border-radius: var(--radius);
     background: var(--tile-bg); color:var(--tile-fg);
     display:flex; align-items:center; justify-content:center; /* older iOS centering */
     line-height:1;                                             /* avoid vertical bias */
     font-weight:900;
     font-size: clamp(24px, 8.5vw, 36px);  /* slightly larger */
     user-select:none;
   }
   .tile{ background:var(--tile-bg); }
   .tile.empty{ color: var(--muted); }
   .btn-letter{ background:var(--btn-bg); }
   .btn-letter[aria-pressed="true"], .btn-letter.used{ opacity:.32; }


   /* ------------------------------
      5) Controls
      ------------------------------ */
   .controls{ display:grid; grid-template-columns: 1fr 1fr; gap: var(--gap); }
   .controls button{ width:100%; }
   .press{ transform: scale(.96); transition: transform 120ms ease; }
   .controls button{ font-weight:700; }
   .card .actions button{ font-weight:700; }
   .theme-bottom{ display:flex; justify-content:center; }


   #themeBtn{
     display:inline-flex; align-items:center; justify-content:center;
     width:48px; height:48px; padding:0;
     border:1px solid var(--border); border-radius: var(--radius); /* rounded square */
     background:var(--btn-bg); color:var(--fg);
   }
   #themeIcon{ width:28px; height:28px; display:block; }


   /* ------------------------------
      6) Spacer to aid tall screens
      ------------------------------ */
   .spacer{ flex:1 1 auto; }


   /* ------------------------------
      7) Animations (motion-only) & reduced-motion
      ------------------------------ */
   @keyframes shake{ 0%,100%{transform:translateX(0)} 20%{transform:translateX(-6px)} 40%{transform:translateX(6px)} 60%{transform:translateX(-4px)} 80%{transform:translateX(4px)} }
   @keyframes jiggle{ 0%,100%{ transform:rotate(0) } 25%{ transform:rotate(-2deg) } 75%{ transform:rotate(2deg) } }
   @keyframes pop{ 0%{ transform:scale(1) } 50%{ transform:scale(1.075) } 100%{ transform:scale(1) } }


   .shake{ animation: shake .22s linear; }
   .jiggle{ animation: jiggle .26s ease-in-out; }
   .pop{ animation: pop .6s ease; }
   /* Soft variants */
   @keyframes shakeSoft{ 0%,100%{ transform:translateX(0) } 20%{ transform:translateX(-3px) } 40%{ transform:translateX(3px) } 60%{ transform:translateX(-2px) } 80%{ transform:translateX(2px) } }
   .shake-soft{ animation: shakeSoft .22s linear; }
   @keyframes popSoft{ 0%{ transform:scale(1) } 50%{ transform:scale(1.03) } 100%{ transform:scale(1) } }
   .pop-soft{ animation: popSoft .45s ease; }

   /* Even subtler shake for the timer (≈30% less movement than shake-soft) */
  @keyframes shakeTiny{
    0%,100%{ transform:translateX(0) }
    20%{ transform:translateX(-2px) }  /* 70% of 3px */
    40%{ transform:translateX( 2px) }
    60%{ transform:translateX(-1px) }  /* 70% of 2px */
    80%{ transform:translateX( 1px) }
  }
  .shake-tiny{ animation: shakeTiny .32s linear; }

   /* Performance hints for smooth transforms */
   .row > .tile, .bank > .btn-letter { will-change: transform; contain: layout paint; }
   .timer-rail { will-change: transform; contain: layout paint; }

   @media (prefers-reduced-motion: reduce){
     .shake, .jiggle, .pop{ animation-duration: .01s; }
     .shake-soft, .pop-soft, .shake-tiny{ animation-duration: .01s; }
     .timer-fill{ transition: none; }
   }


   /* ------------------------------
      8) Modals (Intro, Game Over, Loading/Retry)
      ------------------------------ */
   .overlay{ position:fixed; inset:0; background: rgba(0,0,0,.55); display:none; }
   .overlay[aria-hidden="false"]{ display:block; }
   .dialog{ position:fixed; inset:0; display:none; place-items:center; }
   .dialog[aria-hidden="false"]{ display:grid; pointer-events:auto; }
   .card{ width:min(92vw, 520px); background:var(--bg); color:var(--fg); border:1px solid var(--border); border-radius:16px; padding:20px; box-shadow:none; }
   .card h2{ margin:0 0 10px; letter-spacing:.06em; }
   .card p{ margin:.5rem 0; color:var(--muted); }
   .card .actions{ display:flex; gap:10px; justify-content:flex-end; margin-top:16px; }


   /* ------------------------------
      9) Visually-hidden for a11y
      ------------------------------ */
   .sr-only{
     position:absolute; width:1px; height:1px; padding:0; margin:-1px;
     overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0;
   }
 </style>
</head>
<body>
 <div id="app" class="app pre" aria-live="polite">
   <!-- Header -->
   <header class="header">
     <div></div>
     <div class="title" aria-hidden="true">JUMBL</div>
     <div class="theme-wrap"></div>
   </header>


   <!-- Lives -->
   <div id="lives" class="lives" aria-label="Lives" aria-live="polite"></div>
   <!-- Score -->
   <div id="score" class="score" aria-live="polite">Score: 0</div>


   <!-- Timer -->
   <section class="timer-card">
     <div id="timerRail" class="timer-rail" role="progressbar" aria-label="Time remaining (seconds)" aria-valuemin="0" aria-valuemax="25" aria-valuenow="25">
       <div id="timerFill" class="timer-fill"></div>
     </div>
     <span id="srSeconds" class="sr-only" aria-live="polite"></span>
   </section>


   <!-- Answer row above Letter bank -->
   <section id="answerRow" class="row" aria-label="Your guess"></section>
   <section id="bank" class="bank" aria-label="Letter bank"></section>


   <!-- Controls -->
   <div class="controls">
     <button id="shuffleBtn" type="button" aria-label="Shuffle letters">Shuffle</button>
     <button id="clearBtn" type="button" aria-label="Clear all">Clear</button>
   </div>


   <div class="theme-bottom">
     <button id="themeBtn" class="icon" aria-label="Toggle theme" title="Toggle theme">
       <svg id="themeIcon" viewBox="0 0 24 24" aria-hidden="true"></svg>
     </button>
   </div>


   <div class="spacer" aria-hidden="true"></div>


   <!-- A11y announcer for granular updates (letters placed, etc.) -->
   <div id="announcer" class="sr-only" aria-live="polite"></div>
 </div>


 <!-- Overlay + Dialog (reused for all modals) -->
 <div id="overlay" class="overlay" aria-hidden="true"></div>
 <div id="dialog" class="dialog" aria-hidden="true" aria-modal="true" role="dialog" aria-labelledby="dialogTitle">
   <div class="card" role="document">
     <h2 id="dialogTitle"></h2>
     <div id="dialogBody"></div>
     <div class="actions" id="dialogActions"></div>
   </div>
 </div>


 <script>
 (()=>{
   "use strict";


   /* ------------------------------
      1) Constants / State
      ------------------------------ */
   const COUNTDOWN_SECONDS = 25;
   const STARTING_LIVES = 3;
   const TICK_MS = 100;


   let ANSWER_POOL = [];
   let GUESSES_SET = new Set();


   const state = {
     answerWord: "",
     bank: /** @type {{ch:string, used:boolean}[]} */([]),
     current: ["","","","",""],
     placedIndex: [null,null,null,null,null],
     lives: STARTING_LIVES,
     score: 0,
     runStartAt: 0,
     deadlineAt: 0,
     timerHandle: null,
     isAnimating: false,
     modalOpen: false,
   };


   /* ------------------------------
      2) DOM helpers
      ------------------------------ */
   const $ = (sel, root=document) => root.querySelector(sel);
   const app = $("#app");
   const livesEl = $("#lives");
   const scoreEl = $("#score");
   const timerRail = $("#timerRail");
   const timerFill = $("#timerFill");
   const srSeconds = $("#srSeconds");
   let lastSpokenSecs = null;
   const answerRow = $("#answerRow");
   const bankRow = $("#bank");
   const announcer = $("#announcer");
   const shuffleBtn = $("#shuffleBtn");
   const clearBtn = $("#clearBtn");
   const themeBtn = $("#themeBtn");


   const overlay = $("#overlay");
   const dialog = $("#dialog");
   const dialogTitle = $("#dialogTitle");
   const dialogBody = $("#dialogBody");
   const dialogActions = $("#dialogActions");


   /* ------------------------------
      3) Viewport var --vw updates
      ------------------------------ */
   function setVW(){
     const vv = window.visualViewport;
     const w = (vv ? vv.width  : window.innerWidth)  || window.innerWidth;
     const h = (vv ? vv.height : window.innerHeight) || window.innerHeight;
     // Round to whole pixels to avoid sub-pixel overflow/bleed on older iOS
     document.documentElement.style.setProperty('--vw', Math.round(w) + 'px');
     document.documentElement.style.setProperty('--vh', Math.round(h) + 'px');
   }
   setVW();
   if(window.visualViewport){
     visualViewport.addEventListener('resize', setVW);
     visualViewport.addEventListener('scroll', setVW);
   }
   window.addEventListener('orientationchange', setVW);
   window.addEventListener('resize', setVW);
   window.addEventListener('pageshow', setVW);
   if(window.visualViewport){ visualViewport.addEventListener('resize', syncControlHeights); }
   window.addEventListener('resize', syncControlHeights);


   /* ------------------------------
      3b) Kill pinch/double-tap zoom within the app
      ------------------------------ */
   (function preventZoom(){
     // Safari fires non-standard gesture events for pinch
     ['gesturestart','gesturechange','gestureend'].forEach(type=>{
       app.addEventListener(type, (e)=> e.preventDefault(), { passive:false });
     });


     // Block two-finger pinch on other engines
     app.addEventListener('touchstart', (e)=>{ if(e.touches.length > 1) e.preventDefault(); }, { passive:false });


     // Block iOS double-tap-to-zoom (quick second tap)
     let lastTouchEnd = 0;
     app.addEventListener('touchend', (e)=>{
       const now = Date.now();
       if(now - lastTouchEnd < 350){ e.preventDefault(); }
       lastTouchEnd = now;
     }, { passive:false });
   })();


   /* ------------------------------
      4) Theme (persist localStorage)
      ------------------------------ */
   const THEME_KEY = 'jumbl-theme';
   function applyTheme(t){ document.documentElement.classList.toggle('dark', t === 'dark'); updateThemeIcon(); }
   function getSystemTheme(){ return matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'; }
   function initTheme(){ applyTheme(localStorage.getItem(THEME_KEY) || getSystemTheme()); }
   function toggleTheme(){
     const isDark = document.documentElement.classList.toggle('dark');
     localStorage.setItem(THEME_KEY, isDark ? 'dark' : 'light');
     updateThemeIcon();
   }
   function updateThemeIcon(){
     const isDark = document.documentElement.classList.contains('dark');
     const svg = $("#themeIcon");
     if(!svg) return;
     svg.setAttribute('viewBox','0 0 24 24');
     if(isDark){
       // filled crescent moon
       svg.innerHTML = '<path fill="currentColor" d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>';
     }else{
       // filled sun disc
       svg.innerHTML = '<circle cx="12" cy="12" r="10" fill="currentColor"/>';
     }
   }
   makeTap(themeBtn, toggleTheme);


   /* ------------------------------
      5) Utilities
      ------------------------------ */
   const randInt = n => Math.floor(Math.random()*n);
   function shuffleInPlace(arr){ for(let i=arr.length-1;i>0;i--){ const j = randInt(i+1); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
   function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
   const ANIM_CLASSES = ['shake','shake-soft','shake-tiny','jiggle','pop','pop-soft'];
   function play(el, cls){
     // remove any prior animation classes
     for(const c of ANIM_CLASSES) el.classList.remove(c);
     // restart next frame (avoids forced synchronous layout)
     requestAnimationFrame(()=>{
       el.classList.add(cls);
       el.addEventListener('animationend', ()=> el.classList.remove(cls), { once:true });
     });
   }
   function normalizeList(text){
     // strip BOM
     if(text.charCodeAt(0) === 0xFEFF){ text = text.slice(1); }
     const seen = new Set();
     const out = [];
     text.split(/\r?\n/).forEach(line=>{
       const s = line.trim().toUpperCase();
       if(/^[A-Z]{5}$/.test(s) && !seen.has(s)){ seen.add(s); out.push(s); }
     });
     return out;
   }


   function pickAnswer(){ return ANSWER_POOL[randInt(ANSWER_POOL.length)]; }


   function buildBankFrom(word){
     const arr = word.split("").map(ch=>({ ch, used:false }));
     return shuffleInPlace(arr);
   }


   function secondsSince(ts){ return Math.floor((Date.now()-ts)/1000); }
   function fmtMMSS(total){
     const m = Math.floor(total/60).toString().padStart(2,'0');
     const s = (total%60).toString().padStart(2,'0');
     return `${m}:${s}`;
   }


   /* ------------------------------
      6) Rendering
      ------------------------------ */
   function renderLives(){
     const frag = document.createDocumentFragment();
     for(let i=0;i<STARTING_LIVES;i++){
       const d = document.createElement('div');
       d.className = 'pip' + (i < state.lives ? '' : ' off');
       frag.appendChild(d);
     }
     livesEl.innerHTML = '';
     livesEl.appendChild(frag);
     livesEl.setAttribute('aria-label', `Lives: ${state.lives} of ${STARTING_LIVES}`);
   }


   function renderScore(){ scoreEl.textContent = `Score: ${state.score}`; }


   function renderTimer(){
     const now = performance.now();
     const remain = clamp(state.deadlineAt - now, 0, COUNTDOWN_SECONDS*1000);
     const ratio = remain / (COUNTDOWN_SECONDS*1000);
     timerFill.style.transform = `scaleX(${ratio})`; // right->left via transform-origin:left
     const secs = Math.ceil(remain/1000);
     timerRail.setAttribute('aria-valuenow', String(secs));
     // Speak at most once per second
     if (secs !== lastSpokenSecs) {
       srSeconds.textContent = `${secs} seconds remaining`;
       lastSpokenSecs = secs;
       // Subtle tick in the final 5 seconds
       if (secs <= 5 && secs > 0) { play(timerRail, 'shake-tiny'); }
      }
   }

   function renderAnswer(){
     const frag = document.createDocumentFragment();
     for(let i=0;i<5;i++){
       const v = state.current[i] || '';
       const d = document.createElement('div');
       d.className = 'tile' + (v ? '' : ' empty');
       d.textContent = v;
       d.setAttribute('aria-label', v ? `Slot ${i+1}: ${v}` : `Slot ${i+1}: empty`);
       frag.appendChild(d);
     }
     answerRow.innerHTML = '';
     answerRow.appendChild(frag);
   }


   function renderBank(){
     const frag = document.createDocumentFragment();
     state.bank.forEach((b, idx)=>{
       const btn = document.createElement('button');
       btn.className = 'btn-letter';
       btn.type = 'button';
       btn.textContent = b.ch;
       btn.disabled = b.used;
       btn.setAttribute('aria-pressed', b.used ? 'true' : 'false');
       btn.dataset.idx = String(idx);
       frag.appendChild(btn);
     });
     bankRow.innerHTML = '';
     bankRow.appendChild(frag);
     syncControlHeights();
   }


   function renderUI(){
     renderLives();
     renderScore();
     renderTimer();
     renderAnswer();
     renderBank();
   }


   function syncControlHeights(){
     const tile = bankRow.querySelector('.btn-letter');
     // Use width (square tiles) via offsetWidth to avoid transform-inflated rects
     const w = tile ? Math.round(tile.offsetWidth) : 0;
     if(w){
       const px = w + 'px';
       if (shuffleBtn.style.height !== px) shuffleBtn.style.height = px;
       if (clearBtn.style.height !== px)   clearBtn.style.height   = px;
     }
   }


   /* ------------------------------
      7) Timer control
      ------------------------------ */
   function startTimer(){
     stopTimer();
     state.deadlineAt = performance.now() + COUNTDOWN_SECONDS*1000;
     renderTimer();
     state.timerHandle = setInterval(()=>{
       renderTimer();
       if(performance.now() >= state.deadlineAt){ onTimeout(); }
     }, TICK_MS);
   }
   function stopTimer(){ if(state.timerHandle){ clearInterval(state.timerHandle); state.timerHandle = null; } }


   /* ------------------------------
      8) Core game flow
      ------------------------------ */
   function startRun(){
     app.classList.remove('pre');
     state.lives = STARTING_LIVES;
     state.score = 0;
     state.runStartAt = Date.now();
     nextWord(false);
   }


   function nextWord(increment){
     if(increment) state.score++;
     state.answerWord = pickAnswer();
     state.bank = buildBankFrom(state.answerWord);
     state.current = ["","","","",""];
     state.placedIndex = [null,null,null,null,null];
     state.isAnimating = false;
     renderUI();
     startTimer();
   }


   function onTimeout(){
     if(state.timerHandle === null) return; // already handled
     stopTimer();
     state.lives = Math.max(0, state.lives - 1);
     renderLives();
     // Reveal the correct word in answer row, shake, then advance or game over
     state.isAnimating = true;
     for(let i=0;i<5;i++){ state.current[i] = state.answerWord[i]; }
     renderAnswer();
     play(answerRow, 'shake');
     setTimeout(()=>{
       state.isAnimating = false;
       if(state.lives > 0){ nextWord(false); }
       else{ gameOver(); }
     }, 800);
   }


   function onLetterTap(bankIndex){
     if(state.isAnimating || state.modalOpen) return;
     const idx = state.placedIndex.indexOf(null); // next empty slot
     if(idx === -1) return; // full
     const b = state.bank[bankIndex];
     if(!b || b.used) return;
     b.used = true;
     state.current[idx] = b.ch;
     state.placedIndex[idx] = bankIndex;
     renderAnswer();
     renderBank();
     announcer.textContent = `Placed ${b.ch} in slot ${idx+1}`;
     // slot pop (soft) — only the tile we just filled
     const slotEl = answerRow.children[idx];
     if (slotEl) play(slotEl, 'pop-soft');
     autoSubmitIfFull();
   }


   function onShuffle(){
     if(state.isAnimating || state.modalOpen) return;
     // shuffle only unused letters
     const unused = [];
     const unusedIdx = [];
     state.bank.forEach((b, i)=>{ if(!b.used){ unused.push(b); unusedIdx.push(i); } });
     shuffleInPlace(unused);
     unusedIdx.forEach((slot, j)=>{ state.bank[slot] = unused[j]; });
     renderBank();
     play(bankRow, 'jiggle');
   }


   /* NEW — remove the rightmost placed letter and return it to the bank */
   function onBackspace(opts = { animate: true }){
     if (state.isAnimating || state.modalOpen) return;
     // find rightmost non-empty slot
     let i = -1;
     for (let j = 4; j >= 0; j--) { if (state.current[j]) { i = j; break; } }
     if (i === -1) return; // nothing to remove
     // restore bank letter that originally filled this slot
     const bi = state.placedIndex[i];
     if (bi !== null) { state.bank[bi].used = false; }
     // clear the slot
     state.current[i] = "";
     state.placedIndex[i] = null;
     // re-render UI
     renderAnswer();
     renderBank();
     // small feedback on the slot we edited
     if (opts.animate) {
       const slotEl = answerRow.children[i];
       if (slotEl) play(slotEl, 'shake-soft');
     }
     // a11y announce
     announcer.textContent = `Removed letter from slot ${i+1}`;
   }


   function onClearAll(opts = { animate: true, force: false }){
     // If a PointerEvent accidentally arrives, fall back to defaults
     if (opts && typeof opts === 'object' && ('type' in opts) && ('pointerId' in opts)) {
       opts = { animate: true, force: false };
     }
     // allow clearing during animations only when explicitly forced
     if (!opts.force && (state.isAnimating || state.modalOpen)) return;
     for (let i = 0; i < 5; i++) {
       const bi = state.placedIndex[i];
       if (bi !== null) { state.bank[bi].used = false; }
       state.current[i] = "";
       state.placedIndex[i] = null;
     }
     renderAnswer();
     renderBank();
     // animate clear only if requested (prevents double-shake on invalid)
     if (opts.animate){ play(answerRow, 'shake-soft'); }
   }


   function autoSubmitIfFull(){
     if(state.current.every(c=>c)){
       evaluateGuess(state.current.join(''));
     }
   }


   function evaluateGuess(guess){
     if (GUESSES_SET.has(guess)) {
       // Correct: soft-pop the bar + pop each tile in sync
       stopTimer();
       state.isAnimating = true;
       play(answerRow, 'pop-soft');
       [...answerRow.children].forEach(el => play(el, 'pop'));
       setTimeout(() => {
         state.isAnimating = false;
         nextWord(true);
       }, 600);
       return;
     }
     // Invalid: shake, then clear — robust on older iOS
     state.isAnimating = true;
     play(answerRow, 'shake');
     let cleared = false;
     const finish = () => {
       if (cleared) return;
       cleared = true;
       answerRow.removeEventListener('animationend', finish);
       onClearAll({ animate: false, force: true }); // <— force clears during animation
       state.isAnimating = false;
     };
     // Prefer animationend, but also guard with a timeout
     answerRow.addEventListener('animationend', finish, { once: true });
     setTimeout(finish, 320); // ~.22s shake + buffer
   }


   function gameOver(){
     stopTimer();
     showModal('GAME OVER',
       `<p><strong>${state.score}</strong> words in <strong>${fmtMMSS(secondsSince(state.runStartAt))}</strong></p>`,
       [ {label:'Again', action:()=>{ closeModal(); startRun(); }, isPrimary:true} ]
     );
   }


   /* ------------------------------
      9) Events — clicks & keyboard
      ------------------------------ */
   // Letter taps and keyboard keys: show press while held; commit on release
   bankRow.addEventListener('pointerdown', (e)=>{
     const t = e.target;
     if(!(t instanceof HTMLElement)) return;
     if(!t.classList.contains('btn-letter')) return;
     if (t.disabled) return;
     t.classList.add('press');
     // capture so we always get the matching pointerup/cancel
     if (typeof t.setPointerCapture === 'function') { try { t.setPointerCapture(e.pointerId); } catch {} }
   });


   bankRow.addEventListener('pointerup', (e)=>{
     const t = e.target;
     if(!(t instanceof HTMLElement)) return;
     if(!t.classList.contains('btn-letter')) return;
     t.classList.remove('press');
     if (t.disabled) return; // might have been disabled mid-press
     const idx = Number(t.dataset.idx);
     onLetterTap(idx);
   });


   bankRow.addEventListener('pointercancel', (e)=>{
     const t = e.target;
     if(t instanceof HTMLElement && t.classList.contains('btn-letter')){ t.classList.remove('press'); }
   });


   bankRow.addEventListener('pointerleave', (e)=>{
     const t = e.target;
     if(t instanceof HTMLElement && t.classList.contains('btn-letter')){ t.classList.remove('press'); }
   });


   // Buttons (taps and keyboard keys): stay "pressed" while held; pop back on pointerup, then run action
   function makeTap(btn, handler){
     if(!btn) return;
     btn.addEventListener('pointerdown', () => btn.classList.add('press'));
     btn.addEventListener('pointerup', () => { btn.classList.remove('press'); handler(); });
     btn.addEventListener('pointercancel', () => btn.classList.remove('press'));
     btn.addEventListener('pointerleave', () => btn.classList.remove('press'));
   }


   makeTap(shuffleBtn, onShuffle);
   makeTap(clearBtn, () => onClearAll({ animate: true }));
   makeTap(answerRow, () => onBackspace({ animate: true }));


   // Keyboard-to-UI press tracking (Space/Backspace/letters)
   const keyHold = new Map(); // key -> { type, idx?, el }


   document.addEventListener('keydown', (e)=>{
     // visuals only; actions commit on keyup
     if(state.modalOpen || state.isAnimating) return;
     if(e.repeat) return; // ignore auto-repeats
     const k = e.key;
     // Space ↔ Shuffle
     if(k === ' ' || k === 'Spacebar' || k === 'Space'){
       e.preventDefault();
       shuffleBtn.classList.add('press');
       keyHold.set('Space', { type:'shuffle', el: shuffleBtn });
       return;
     }
     // Backspace/Delete ↔ Clear
     if(k === 'Backspace' || k === 'Delete'){
       e.preventDefault();
       clearBtn.classList.add('press');
       keyHold.set('Clear', { type:'clear', el: clearBtn });
       return;
     }
     // A–Z keys map to the first unused matching bank letter
     if(k.length === 1){
       const ch = k.toUpperCase();
       if(ch < 'A' || ch > 'Z') return;
       const i = state.bank.findIndex(b => !b.used && b.ch === ch);
       if(i !== -1){
         const btn = bankRow.querySelectorAll('.btn-letter')[i];
         if(btn){ btn.classList.add('press'); keyHold.set(ch, { type:'letter', idx:i, el: btn }); }
       }
     }
   }, true);


   document.addEventListener('keyup', (e)=>{
     const k = e.key;
     let hold = null;
     if(k === ' ' || k === 'Spacebar' || k === 'Space') hold = keyHold.get('Space');
     else if(k === 'Backspace' || k === 'Delete') hold = keyHold.get('Clear');
     else if(k.length === 1) hold = keyHold.get(k.toUpperCase());
     if(!hold) return;
     // Always clear the visual press
     if(hold.el && hold.el.classList) hold.el.classList.remove('press');
     keyHold.delete(k === ' ' || k === 'Spacebar' || k === 'Space' ? 'Space' : (k === 'Backspace' || k === 'Delete' ? 'Clear' : k.toUpperCase()));
     // If a modal opened or animation started, abort action
     if(state.modalOpen || state.isAnimating) return;
     if(hold.type === 'shuffle'){ onShuffle(); return; }
     if(hold.type === 'clear'){ onClearAll({ animate: true }); return; }
     if(hold.type === 'letter'){ onLetterTap(hold.idx); }
   }, true);


   window.addEventListener('blur', ()=>{
     // Remove any stuck .press when focus leaves the window
     for(const h of keyHold.values()){ if(h.el && h.el.classList) h.el.classList.remove('press'); }
     keyHold.clear();
   });


   /* ------------------------------
      10) Modals (reusable) + focus mgmt
      ------------------------------ */
   let restoreFocusEl = null;
   // NEW — modal keyboard handling (Enter/Space press + commit)
   let modalHeldBtn = null;
   function onModalKeyDown(e){
     if(e.key !== 'Enter' && e.key !== ' ') return;
     const t = document.activeElement;
     if(!(t instanceof HTMLElement)) return;
     if(!dialog.contains(t)) return;
     if(t.tagName !== 'BUTTON') return;
     e.preventDefault(); // prevent scrolling/submit defaults
     t.classList.add('press');
     modalHeldBtn = t;
   }
   function onModalKeyUp(e){
     if(e.key !== 'Enter' && e.key !== ' ') return;
     const t = (modalHeldBtn && dialog.contains(modalHeldBtn)) ? modalHeldBtn : document.activeElement;
     modalHeldBtn = null;
     if(!(t instanceof HTMLElement)) return;
     if(!dialog.contains(t)) return;
     if(t.tagName !== 'BUTTON') return;
     t.classList.remove('press');
     // Prefer the action we attached; fall back to click() if present.
     if (typeof t.__action === 'function') { t.__action(); }
     else if (typeof t.click === 'function') { t.click(); }
   }


   function showModal(title, bodyHTML, actions){
     state.modalOpen = true;
     app.classList.add('masked');
     overlay.setAttribute('aria-hidden','false');
     dialog.setAttribute('aria-hidden','false');
     dialogTitle.textContent = title;
     dialogBody.innerHTML = bodyHTML;
     dialogActions.innerHTML = '';
     actions.forEach(a=>{
       const b = document.createElement('button');
       b.type = 'button';
       b.textContent = a.label;
       if(a.isPrimary) b.autofocus = true;
       makeTap(b, a.action);
       b.__action = a.action;
       dialogActions.appendChild(b);
     });
     restoreFocusEl = document.activeElement;
     const firstBtn = dialogActions.querySelector('button') || dialog.querySelector('button');
     if(firstBtn) firstBtn.focus();
     // basic trap
     dialog.addEventListener('keydown', trapTab);
     document.addEventListener('keydown', escClose);
     app.setAttribute('aria-hidden','true');
     dialog.addEventListener('keydown', onModalKeyDown, true);
     document.addEventListener('keyup', onModalKeyUp, true);
   }


   function closeModal(){
     state.modalOpen = false;
     app.classList.remove('masked');
     overlay.setAttribute('aria-hidden','true');
     dialog.setAttribute('aria-hidden','true');
     dialog.removeEventListener('keydown', trapTab);
     document.removeEventListener('keydown', escClose);
     app.removeAttribute('aria-hidden');
     dialog.removeEventListener('keydown', onModalKeyDown, true);
     document.removeEventListener('keyup', onModalKeyUp, true);
     if(restoreFocusEl && restoreFocusEl.focus) restoreFocusEl.focus();
   }


   function trapTab(e){
     if(e.key !== 'Tab') return;
     const focusables = dialog.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
     if(!focusables.length) return;
     const first = focusables[0]; const last = focusables[focusables.length-1];
     if(e.shiftKey && document.activeElement === first){ e.preventDefault(); last.focus(); }
     else if(!e.shiftKey && document.activeElement === last){ e.preventDefault(); first.focus(); }
   }
   function escClose(e){ if(e.key === 'Escape'){ closeModal(); } }


   function showLoading(msg, canRetry){
     const retryBtn = { label:'Retry', action:()=>{ closeModal(); loadWordLists(); }, isPrimary:true };
     showModal('Loading word lists…', `<p>${msg}</p>`, canRetry ? [retryBtn] : []);
   }


   function showIntro(){
     const body = `
       <p>Un-JUMBL the letters to make a 5-letter word.</p>
       <p>Beat the clock to increase your score and refill the timer.</p>
       <p>If the timer hits zero, you lose a life.</p>
       <p><strong>25 seconds</strong> per word • <strong>3 lives</strong></p>
       <p>Highest score wins.</p>`;
     showModal('RULES', body, [ {label:'Play', action:()=>{ closeModal(); startRun(); }, isPrimary:true} ]);
   }


   /* ------------------------------
      11) Data loading & validation
      ------------------------------ */
   async function loadWordLists(){
     showLoading('Fetching…', false);
     try{
       const ctrl = new AbortController();
       const opts = { cache: 'no-store', signal: ctrl.signal };
       const [aRes, gRes] = await Promise.all([
         fetch('answers.txt', opts),
         fetch('guesses.txt', opts)
       ]);
       if(!aRes.ok || !gRes.ok) throw new Error('Network error while fetching lists.');
       const [aText, gText] = await Promise.all([aRes.text(), gRes.text()]);
       const answers = normalizeList(aText);
       const guesses = normalizeList(gText);
       if(!answers.length || !guesses.length) throw new Error('One or both files are empty after parsing.');
       // Build sets and validate subset (ensure answers ⊆ guesses)
       const gSet = new Set(guesses);
       const missing = answers.filter(w => !gSet.has(w));
       if(missing.length){
         showModal(
           'Error in word lists',
           `<p>All answers must also appear in <code>guesses.txt</code>.</p><p>Missing ${missing.length} entries. Example: <code>${missing.slice(0,5).join(', ')}</code></p>`,
           [ {label:'Retry', action:()=>{ closeModal(); loadWordLists(); }, isPrimary:true} ]
         );
         return;
       }
       ANSWER_POOL = answers;
       GUESSES_SET = gSet;
       closeModal();
       // After lists load, show Intro
       showIntro();
     }catch(err){
       console.error(err);
       showLoading('Error loading word lists. Please try again.', true);
     }
   }


   /* ------------------------------
      12) Boot
      ------------------------------ */
   initTheme();
   loadWordLists();
 })();
 </script>
</body>
</html>
