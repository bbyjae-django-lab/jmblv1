<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>JUMBL</title>
  <meta name="color-scheme" content="light dark">

  <!--
    JUMBL — Single-file mobile-first prototype
    ------------------------------------------------------------
    Usage:
      1) Place this index.html alongside answers.txt and guesses.txt
      2) Serve the folder over HTTP, e.g.:
         python3 -m http.server
      3) Open on iPhone Safari (portrait), or desktop

    Files:
      answers.txt  -> UPPERCASE 5-letter ANSWERS (one per line)
      guesses.txt  -> UPPERCASE accepted words (must include all answers)

    Keyboard shortcuts (desktop):
      Space   -> Shuffle
      Backspace/Delete -> Clear all
  -->

  <style>
    :root {
      /* Layout rules that prevent stretching */
      --tile: clamp(68px, 9.5vw, 84px);
      --gap: 16px;
      --row-gap: 18px;

      /* Colors (light default) */
      --bg: #FBFBFD;
      --fg: #1B1E27;
      --muted: #596072;
      --track: #ECECEC;
      --tile-bg: #FFFFFF;
      --tile-fg: #111317;
      --accent: #EE7FB2; /* placed letters */
      --bank-grad: linear-gradient(135deg, #F6C58F 0%, #E8A6D8 100%);

      /* Shadows */
      --shadow: 0 10px 24px rgba(0,0,0,.08);
      --inner: inset 0 1px 0 rgba(255,255,255,.35);

      /* Timer */
      --timer-h: 14px;
      --radius-xl: 16px;
      --radius-xxl: 9999px;
    }

    :root[data-theme="dark"] {
      --bg:#12151C;
      --fg:#F7F7FA;
      --muted:#B6BCD1;
      --track:#2A2E39;
      --tile-bg:#1B2030;
      --tile-fg:#F7F7FA;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      min-height: 100svh;
      padding-bottom: max(20px, env(safe-area-inset-bottom));
      background: var(--bg);
      color: var(--fg);
      font: 500 16px/1.2 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      display: grid;
      grid-template-rows: auto auto 1fr auto;
      justify-items: center;
    }

    .wrap {
      width: 100%;
      max-width: 520px;
      padding: 18px 18px 0;
    }

    header {
      position: relative;
      text-align: center;
      margin-block: 6px 8px;
    }
    header h1 {
      margin: 0;
      letter-spacing: 2px;
      font-weight: 800;
      font-size: clamp(20px, 5vw, 24px);
    }
    .theme-toggle {
      position: absolute;
      right: 0;
      top: 0;
      border: 0;
      background: transparent;
      color: var(--fg);
      padding: 6px 10px;
      border-radius: 10px;
      cursor: pointer;
    }

    /* Status stack */
    .status {
      width: 100%;
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-bottom: 10px;
    }
    .status-row {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      width: 100%;
    }
    .level {
      justify-self: start;
      font-weight: 700;
    }
    .lives {
      justify-self: center;
      display: grid;
      grid-auto-flow: column;
      gap: 6px;
      align-items: center;
    }
    .life {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      background: var(--fg);
      box-shadow: var(--inner);
      opacity: 1;
    }
    .life.lost { opacity: .18; }
    .clock {
      justify-self: end;
      font-variant-numeric: tabular-nums;
      color: var(--muted);
      font-size: 14px;
    }

    /* Timer Bar spec */
    .timer {
      width: 100%;
      height: var(--timer-h);
      background: var(--track);
      border-radius: var(--radius-xxl);
      box-shadow: var(--inner);
      overflow: hidden;
      position: relative;
    }
    .timer-fill {
      height: 100%;
      width: 100%;
      background: var(--bank-grad);
      border-radius: var(--radius-xxl);
      transition: width .2s linear;
      will-change: width;
    }

    /* Tile grids (exactly as specified) */
    .rows {
      display: grid;
      justify-items: center;
      gap: 0;
      margin: 18px 0 10px;
    }

    .answer, .bank {
      display: inline-grid;
      grid-template-columns: repeat(5, var(--tile));
      gap: var(--gap);
      width: min-content;        /* grid = just tiles + gaps */
      margin-inline: auto;       /* center the block */
      align-items: start;        /* never stretch items vertically */
    }
    .answer { margin-block-end: var(--row-gap); }  /* spacing above the bank */
    .bank   { margin-block-end: 14px; }            /* tight spacing above controls */

    .slot, .letter {
      width: var(--tile);
      height: var(--tile);
      display: grid;
      place-items: center;
      border-radius: 16px;
      box-shadow: var(--shadow), var(--inner);
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      font-weight: 800;
      letter-spacing: .5px;
      font-size: clamp(22px, 3.2vw, 28px);
      text-transform: uppercase;
    }

    .slot {
      background: var(--tile-bg);
      color: var(--accent); /* placed letters */
      border: 1px solid rgba(0,0,0,.04);
    }
    .slot.empty {
      color: transparent; /* keep height */
    }
    .slot.locked {
      outline: 2px solid rgba(238,127,178,.8);
      color: var(--tile-fg);
      background: color-mix(in srgb, var(--tile-bg) 85%, #EE7FB2 15%);
    }

    .letter {
      background: var(--bank-grad);
      color: #222;
      cursor: pointer;
      transform: translateZ(0);
    }
    .letter.used {
      opacity: .18;
      pointer-events: none;
    }

    /* Controls */
    .controls {
      display: grid;
      grid-auto-flow: column;
      gap: 12px;
      justify-content: center;
      padding-bottom: 6px;
    }
    .btn {
      min-width: 140px;
      padding: 14px 16px;
      border-radius: 16px;
      border: 0;
      background: var(--tile-bg);
      color: var(--fg);
      box-shadow: var(--shadow), var(--inner);
      font-weight: 700;
      cursor: pointer;
    }
    .btn:active { transform: translateY(1px); }

    /* Animations (reduced for motion-sensitive users) */
    @media (prefers-reduced-motion: reduce) {
      .timer-fill { transition: none; }
      .pop, .shake { animation: none !important; }
    }
    @keyframes pop {
      0% { transform: scale(1); }
      40% { transform: scale(1.06); }
      100% { transform: scale(1); }
    }
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      20% { transform: translateX(-6px); }
      40% { transform: translateX(6px); }
      60% { transform: translateX(-4px); }
      80% { transform: translateX(4px); }
    }

    .pop { animation: pop .25s ease; }
    .shake { animation: shake .25s ease; }

    /* Modal */
    .scrim {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.4);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
    }
    .scrim.show { display: flex; }
    .modal {
      width: min(520px, 92vw);
      background: var(--tile-bg);
      color: var(--fg);
      border-radius: 20px;
      box-shadow: var(--shadow);
      padding: 20px 18px;
    }
    .modal h2 {
      margin: 0 0 8px;
      font-size: 20px;
    }
    .modal p {
      margin: 0 0 16px;
      color: var(--muted);
    }
    .modal .btn {
      width: 100%;
    }

    /* Visually hidden utility */
    .visually-hidden {
      position: absolute !important;
      width: 1px; height: 1px;
      padding: 0; margin: -1px;
      overflow: hidden;
      clip: rect(0 0 0 0);
      white-space: nowrap;
      border: 0;
    }

    /* HTTP error overlay */
    #httpError {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: var(--bg);
      padding: 24px;
      text-align: center;
    }
    #httpError.show { display: flex; }
    #httpError .card {
      background: var(--tile-bg);
      padding: 20px;
      border-radius: 16px;
      box-shadow: var(--shadow);
      max-width: 520px;
    }
    #httpError code {
      background: #00000014;
      padding: 2px 6px;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <div id="httpError" role="alert" aria-live="assertive">
    <div class="card">
      <h2>Can’t load word lists</h2>
      <p>Serve files over HTTP (e.g., <code>python3 -m http.server</code>) to load <em>answers.txt</em> and <em>guesses.txt</em>.</p>
    </div>
  </div>

  <div class="wrap">
    <header>
      <h1>JUMBL</h1>
      <button class="theme-toggle" id="themeBtn" aria-pressed="false" title="Toggle theme">◐</button>
    </header>

    <section class="status">
      <div class="status-row">
        <div class="level" id="level">Level 1</div>
        <div class="lives" id="lives" aria-label="Lives"></div>
        <div class="clock" id="clock">00:25</div>
      </div>

      <div class="timer" role="progressbar" aria-valuemin="0" aria-valuemax="25" aria-valuenow="25" aria-label="Time remaining">
        <div class="timer-fill" id="timerFill" style="width:100%"></div>
      </div>
      <div class="visually-hidden" aria-live="polite" id="timeLive">25 seconds remaining</div>
    </section>

    <section class="rows" id="rows">
      <div class="answer" id="answerRow" aria-label="Answer row"></div>
      <div class="bank" id="bankRow" aria-label="Letter bank"></div>
    </section>

    <nav class="controls">
      <button class="btn" id="shuffleBtn">⤮ Shuffle</button>
      <button class="btn" id="clearBtn">⌦ Clear all</button>
    </nav>
  </div>

  <!-- Game Over modal -->
  <div class="scrim" id="scrim" role="dialog" aria-modal="true" aria-labelledby="goTitle" aria-describedby="goDesc">
    <div class="modal">
      <h2 id="goTitle">no more lives</h2>
      <p id="goDesc">—</p>
      <button class="btn" id="againBtn">try again ➜</button>
    </div>
  </div>

  <script>
    ;(() => {
      // ---------- State ----------
      const TIMER_MS = 25000;
      const TICK_MS = 200;

      let ANSWERS = [];
      let ACCEPTED_SET = new Set();

      let answerWord = "";
      let locked = Array(5).fill(false);
      let current = Array(5).fill("");
      let placedIndex = Array(5).fill(-1); // maps answer slot -> bank index
      let bank = []; // [{ch, used, iOriginal}]
      let lives = 3;
      let level = 1;
      let deadline = 0;
      let tickId = 0;
      let runStart = 0;
      let animating = false;
      let gameActive = false;

      // ---------- DOM ----------
      const levelEl = document.getElementById("level");
      const livesEl = document.getElementById("lives");
      const clockEl = document.getElementById("clock");
      const timerFill = document.getElementById("timerFill");
      const timeLive = document.getElementById("timeLive");
      const answerRow = document.getElementById("answerRow");
      const bankRow = document.getElementById("bankRow");
      const shuffleBtn = document.getElementById("shuffleBtn");
      const clearBtn = document.getElementById("clearBtn");
      const scrim = document.getElementById("scrim");
      const againBtn = document.getElementById("againBtn");
      const themeBtn = document.getElementById("themeBtn");
      const httpError = document.getElementById("httpError");

      // ---------- Utilities ----------
      const fmt = (ms) => {
        const s = Math.max(0, Math.ceil(ms / 1000));
        const m = Math.floor(s / 60);
        const sec = s % 60;
        return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
      };

      const randInt = (n) => Math.floor(Math.random() * n);

      const shuffle = (arr, indices = null) => {
        if (indices) {
          for (let i = indices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            const a = indices[i], b = indices[j];
            [arr[a], arr[b]] = [arr[b], arr[a]];
          }
        } else {
          for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
          }
        }
      };

      const setTheme = (theme) => {
        document.documentElement.setAttribute("data-theme", theme);
        themeBtn.setAttribute("aria-pressed", theme === "dark" ? "true" : "false");
        localStorage.setItem("jumbl-theme", theme);
      };
      const toggleTheme = () => {
        const cur = document.documentElement.getAttribute("data-theme") || "light";
        setTheme(cur === "light" ? "dark" : "light");
      };

      // ---------- Rendering ----------
      function renderStatus(msLeft = TIMER_MS) {
        levelEl.textContent = `Level ${level}`;

        // Lives (3 small squares)
        livesEl.innerHTML = "";
        for (let i = 0; i < 3; i++) {
          const d = document.createElement("div");
          d.className = "life" + (i < lives ? "" : " lost");
          livesEl.appendChild(d);
        }

        clockEl.textContent = fmt(msLeft);
        const sLeft = Math.max(0, Math.ceil(msLeft / 1000));
        timeLive.textContent = `${sLeft} seconds remaining`;
        const p = Math.max(0, Math.min(1, msLeft / TIMER_MS));
        timerFill.style.width = (p * 100).toFixed(1) + "%";
        const bar = timerFill.parentElement;
        bar.setAttribute("aria-valuenow", String(Math.ceil(msLeft/1000)));
      }

      function renderRows() {
        // Answer row (top)
        answerRow.innerHTML = "";
        for (let i = 0; i < 5; i++) {
          const ch = current[i] || "";
          const d = document.createElement("div");
          d.className = "slot" + (locked[i] ? " locked" : (ch ? "" : " empty"));
          d.textContent = ch || "•";
          answerRow.appendChild(d);
        }

        // Bank row (bottom)
        bankRow.innerHTML = "";
        bank.forEach((item, idx) => {
          const d = document.createElement("button");
          d.type = "button";
          d.className = "letter" + (item.used ? " used" : "");
          d.textContent = item.ch;
          d.addEventListener("click", () => onLetterTap(idx));
          bankRow.appendChild(d);
        });
      }

      function renderAll(msLeft = TIMER_MS) {
        renderStatus(msLeft);
        renderRows();
      }

      // ---------- Game Flow ----------
      function buildBankFromAnswer() {
        bank = answerWord.split("").map((ch, i) => ({ ch, used: false, iOriginal: i }));
        shuffle(bank);
      }

      function startTimer(refill = true) {
        if (tickId) clearInterval(tickId);
        if (refill) deadline = Date.now() + TIMER_MS;
        renderStatus(TIMER_MS);
        tickId = setInterval(tick, TICK_MS);
      }

      function tick() {
        const now = Date.now();
        const msLeft = deadline - now;
        if (msLeft <= 0) {
          // Timeout rule
          loseLife();
          if (lives <= 0) return;
          // Reshuffle only unused/unlocked bank letters
          refreshShuffle();
          // Refill timer
          deadline = Date.now() + TIMER_MS;
          renderAll(TIMER_MS);
        } else {
          renderStatus(msLeft);
        }
      }

      function pickAnswer() {
        answerWord = ANSWERS[randInt(ANSWERS.length)];
      }

      function startGame() {
        gameActive = true;
        runStart = Date.now();
        lives = 3;
        level = 1;
        locked = Array(5).fill(false);
        current = Array(5).fill("");
        placedIndex = Array(5).fill(-1);
        pickAnswer();
        buildBankFromAnswer();
        renderAll(TIMER_MS);
        startTimer(true);
      }

      function nextLevel() {
        level += 1;
        locked = Array(5).fill(false);
        current = Array(5).fill("");
        placedIndex = Array(5).fill(-1);
        pickAnswer();
        buildBankFromAnswer();
        renderAll(TIMER_MS);
        startTimer(true);
      }

      function onLetterTap(bi) {
        if (!gameActive) return;
        const item = bank[bi];
        if (item.used) return;

        // Find next unlocked empty answer slot
        let slot = -1;
        for (let i = 0; i < 5; i++) {
          if (!locked[i] && !current[i]) { slot = i; break; }
        }
        if (slot === -1) return;

        current[slot] = item.ch;
        placedIndex[slot] = bi;
        item.used = true;
        renderRows();
        autoSubmitIfFull();
      }

      function onClearAll() {
        if (!gameActive) return;
        for (let i = 0; i < 5; i++) {
          if (!locked[i] && current[i]) {
            const bi = placedIndex[i];
            if (bi !== -1) bank[bi].used = false;
            current[i] = "";
            placedIndex[i] = -1;
          }
        }
        renderRows();
      }

      function refreshShuffle() {
        // Shuffle only unused (not used) bank letters; keep used in place
        const freeIdx = [];
        for (let i = 0; i < bank.length; i++) if (!bank[i].used) freeIdx.push(i);
        shuffle(bank, freeIdx);
        renderRows();
      }

      function loseLife() {
        lives -= 1;
        renderStatus(0);
        if (lives <= 0) {
          gameOver();
        }
      }

      function autoSubmitIfFull() {
        // all filled if every slot either locked or has a letter
        const full = current.every((ch, i) => locked[i] || ch);
        if (!full) return;
        if (animating) return;

        const guess = current.map((ch, i) => (ch || (locked[i] ? answerWord[i] : ""))).join("");
        if (guess.length !== 5) return;

        if (guess === answerWord) {
          // Correct
          animating = true;
          answerRow.classList.remove("shake");
          answerRow.classList.add("pop");
          setTimeout(() => {
            answerRow.classList.remove("pop");
            animating = false;
            nextLevel();
          }, 250);
          return;
        }

        if (ACCEPTED_SET.has(guess)) {
          // Valid but wrong -> lose life, lock correct positions, clear the rest, continue
          loseLife();
          if (lives <= 0) return; // Game over interrupts
          lockCorrectFrom(guess);
          // Clear non-locked slots & free their bank indices
          for (let i = 0; i < 5; i++) {
            if (!locked[i] && current[i]) {
              const bi = placedIndex[i];
              if (bi !== -1) bank[bi].used = false;
              current[i] = "";
              placedIndex[i] = -1;
            }
          }
          renderRows();
        } else {
          // Invalid -> shake + clear, no life loss
          animating = true;
          answerRow.classList.remove("pop");
          answerRow.classList.add("shake");
          setTimeout(() => {
            answerRow.classList.remove("shake");
            animating = false;
          }, 250);
          onClearAll();
        }
      }

      function lockCorrectFrom(guess) {
        for (let i = 0; i < 5; i++) {
          if (guess[i] === answerWord[i]) {
            locked[i] = true;
            // Keep the letter in place; bank index stays used
          }
        }
      }

      function gameOver() {
        gameActive = false;
        if (tickId) clearInterval(tickId);
        const runMs = Date.now() - runStart;
        const s = Math.round(runMs / 1000);
        const m = Math.floor(s / 60);
        const sec = s % 60;
        const runStr = `${m}m ${sec}s`;
        const msg = `run time ${runStr} · levels completed ${level - 1}`;
        document.getElementById("goDesc").textContent = msg;
        scrim.classList.add("show");
        document.body.setAttribute("inert", "");
        setTimeout(() => againBtn.focus(), 0);
      }

      function hideGameOver() {
        scrim.classList.remove("show");
        document.body.removeAttribute("inert");
      }

      // ---------- Data Loading ----------
      async function loadWordLists() {
        try {
          const [aRes, gRes] = await Promise.all([
            fetch("answers.txt"),
            fetch("guesses.txt")
          ]);
          if (!aRes.ok || !gRes.ok) throw new Error("Fetch failed");
          const [aTxt, gTxt] = await Promise.all([aRes.text(), gRes.text()]);
          ANSWERS = aTxt.split(/\r?\n/).map(s => s.trim().toUpperCase()).filter(Boolean);
          const guesses = gTxt.split(/\r?\n/).map(s => s.trim().toUpperCase()).filter(Boolean);
          ACCEPTED_SET = new Set(guesses);
          if (ANSWERS.length === 0 || ACCEPTED_SET.size === 0) throw new Error("Empty lists");
          // Ensure all answers are accepted
          for (const w of ANSWERS) ACCEPTED_SET.add(w);
          httpError.classList.remove("show");
          startGame();
        } catch (err) {
          console.error(err);
          httpError.classList.add("show");
        }
      }

      // ---------- Events ----------
      shuffleBtn.addEventListener("click", refreshShuffle);
      clearBtn.addEventListener("click", onClearAll);
      againBtn.addEventListener("click", () => { hideGameOver(); startGame(); });
      themeBtn.addEventListener("click", toggleTheme);

      // Keyboard shortcuts (desktop)
      window.addEventListener("keydown", (ev) => {
        if (ev.repeat) return;
        const tag = (ev.target && ev.target.tagName) || "";
        if (tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT" || ev.isComposing) return;
        if (ev.code === "Space") { ev.preventDefault(); refreshShuffle(); }
        if (ev.code === "Backspace" || ev.code === "Delete") { ev.preventDefault(); onClearAll(); }
      });

      // Theme boot
      const savedTheme = localStorage.getItem("jumbl-theme");
      if (savedTheme === "dark" || savedTheme === "light") setTheme(savedTheme);
      else setTheme("light");

      // Go!
      loadWordLists();
    })();
  </script>
</body>
</html>
