<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>JUMBL</title>
  <style>
    /* ------------------------------
       0) Base / Theme / Resets
       ------------------------------ */
    :root{
      color-scheme: light dark;
      /* Light */
      --bg:#F6F7FB; --fg:#0F1220; --muted:#6B7280; --track:#ECECEC;
      --tile-bg:#FFFFFF; --tile-fg:#111827; --btn-bg:#FFFFFF; --btn-fg:#0F1220;
      --accent:#3B82F6; --danger:#EF4444; --shadow:0 6px 20px rgba(0,0,0,.08); --radius:16px;
      --card-radius:24px;
    }
    html.dark{
      /* Dark */
      --bg:#0F1115; --fg:#E6E7EB; --muted:#9AA1AA; --track:#1F2430;
      --tile-bg:#171A20; --tile-fg:#F7F7FA; --btn-bg:#171A20; --btn-fg:#E6E7EB;
      --accent:#7CB2FF; --danger:#FF6B88; --shadow:0 8px 24px rgba(0,0,0,.35); --radius:16px;
      --card-radius:24px;
    }

    *{ box-sizing: border-box }
    html, body{ height:100%; }
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font-family: system-ui, -apple-system, "SF Pro Text", Segoe UI, Roboto, Arial, sans-serif;
      height:100dvh; min-height:100dvh; overflow:hidden; overscroll-behavior:none;
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
      -webkit-tap-highlight-color: transparent; /* keep :focus-visible outlines */
    }

    /* Dynamic viewport sizing via CSS vars set by JS */
    .app{
      width: min(var(--vw, 100vw), 600px);
      margin: 0 auto;
      padding-top: calc(env(safe-area-inset-top) + 16px);
      padding-bottom: calc(env(safe-area-inset-bottom) + 18px);
      padding-left: 16px; padding-right:16px;
      display:flex; flex-direction:column; gap:14px;
      min-height:100%;
    }

    .header{ display:grid; grid-template-columns: 1fr auto 1fr; align-items:center; }
    .header h1{ grid-column:2; margin:0; text-align:center; font-size: clamp(20px, 4.2vw, 28px); letter-spacing:2px; }
    .theme-toggle{ grid-column:3; justify-self:end; border:none; background:transparent; cursor:pointer; width:40px; height:40px; border-radius:999px; display:grid; place-items:center; }
    .theme-toggle:focus-visible{ outline:2px solid var(--accent); outline-offset:2px }

    .lives{ display:flex; gap:10px; justify-content:center; align-items:center; margin-top:2px; }
    .pip{ width:12px; height:12px; border-radius:999px; background:currentColor; opacity:.25 }
    .pip.on{ opacity:1 }

    .level{ text-align:center; font-weight:600; margin-top:2px; }

    .timer-card{ background: var(--btn-bg); border-radius: var(--card-radius); box-shadow: var(--shadow); padding:12px; }
    .timer{ position:relative; height:14px; background:var(--track); border-radius:9999px; overflow:hidden; }
    .timer-fill{ position:absolute; left:0; top:0; bottom:0; width:100%; background: var(--accent); transform-origin:left center; transition: width 100ms linear; }
    .timer-wrap[aria-hidden="true"]{ display:none }

    .rows{ display:flex; flex-direction:column; gap:12px; }
    .grid5{ display:grid; grid-template-columns: repeat(5, 1fr); gap:10px; }

    .tile, .bank-btn{
      aspect-ratio: 1 / 1; min-width:56px; min-height:56px;
      display:grid; place-items:center; border-radius: var(--radius);
      box-shadow: var(--shadow); user-select:none;
    }
    .tile{ background: var(--tile-bg); color: var(--tile-fg); font-weight:700; font-size: clamp(20px, 6.2vw, 28px); position:relative; }
    .tile.locked::after{ content:"\1F512"; position:absolute; right:8px; top:6px; font-size:14px; opacity:.6 }

    .bank-btn{ background: var(--btn-bg); color: var(--btn-fg); font-weight:800; font-size: clamp(18px, 5.6vw, 26px); border:none; cursor:pointer; transition: transform .1s ease; }
    .bank-btn:disabled{ opacity:.35; cursor:default }
    .bank-btn:active{ transform: scale(.96) }
    .bank-btn:focus-visible{ outline:2px solid var(--accent); outline-offset:2px }

    .controls{ display:flex; gap:12px; justify-content:center; }
    .btn{ min-width:120px; min-height:44px; padding:12px 16px; border-radius: var(--radius); box-shadow: var(--shadow); border:none; background: var(--btn-bg); color: var(--btn-fg); font-weight:700; cursor:pointer; transition: transform .1s ease }
    .btn:active{ transform: scale(.96) }
    .btn:focus-visible{ outline:2px solid var(--accent); outline-offset:2px }

    .spacer{ flex:1 }

    /* Animations (motion-only) */
    @keyframes pop { from{ transform:scale(.92) } to{ transform:scale(1) } }
    @keyframes shake { 0%,100%{ transform:translateX(0) } 25%{ transform:translateX(-6px) } 75%{ transform:translateX(6px) } }
    @keyframes jiggle { 0%,100%{ transform:rotate(0deg) } 25%{ transform:rotate(-1.6deg) } 75%{ transform:rotate(1.6deg) } }
    @keyframes shudder { 0%,100%{ transform:translateX(0) } 20%{ transform:translateX(-2px) } 40%{ transform:translateX(2px) } 60%{ transform:translateX(-2px) } 80%{ transform:translateX(2px) } }

    .pop{ animation: pop .2s ease-out }
    .shake{ animation: shake .22s ease-in-out }
    .jiggle{ animation: jiggle .26s ease-in-out }
    .shudder{ animation: shudder .85s ease-in-out }

    @media (prefers-reduced-motion: reduce){
      .pop, .shake, .jiggle, .shudder{ animation: none !important }
      .bank-btn, .btn{ transition:none }
      .timer-fill{ transition:none }
    }

    /* Modals */
    .modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.36); backdrop-filter:saturate(120%) blur(2px); padding:24px; }
    .modal.open{ display:flex }
    .dialog{ width:min(520px, 92vw); background: var(--btn-bg); color: var(--btn-fg); border-radius: var(--card-radius); box-shadow: var(--shadow); padding:20px }
    .dialog h2{ margin:0 0 8px 0; font-size:20px }
    .dialog p{ margin:6px 0; color: var(--muted) }

    .sr-only{ position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0 }
  </style>
</head>
<body>
  <div id="app" class="app" aria-live="polite">
    <header class="header" aria-label="Header">
      <div></div>
      <h1>JUMBL</h1>
      <button id="themeToggle" class="theme-toggle" aria-label="Toggle theme" title="Toggle theme" type="button"></button>
    </header>

    <div class="lives" aria-label="Lives">
      <div class="pip on" aria-hidden="true"></div>
      <div class="pip on" aria-hidden="true"></div>
      <div class="pip on" aria-hidden="true"></div>
      <span id="livesText" class="sr-only">Lives: 3 of 3</span>
    </div>

    <div id="level" class="level" aria-label="Level">Level 1</div>

    <section class="timer-card">
      <div id="timerWrap" class="timer-wrap" role="presentation">
        <div id="timer" class="timer" role="progressbar" aria-valuemin="0" aria-valuemax="25" aria-valuenow="25" aria-label="Time remaining">
          <div id="timerFill" class="timer-fill" style="width:100%"></div>
        </div>
      </div>
      <div id="announce" class="sr-only" aria-live="polite"></div>
    </section>

    <main class="rows">
      <section id="answerRow" class="grid5" aria-label="Your guess"></section>
      <section id="bankRow" class="grid5" aria-label="Letter bank"></section>
    </main>

    <nav class="controls" aria-label="Controls">
      <button id="shuffleBtn" class="btn" type="button">Shuffle</button>
      <button id="clearBtn" class="btn" type="button" aria-keyshortcuts="Backspace Delete">Clear all</button>
    </nav>

    <div class="spacer"></div>
  </div>

  <!-- Intro / Rules Modal -->
  <div id="introModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="introTitle">
    <div class="dialog">
      <h2 id="introTitle">RULES</h2>
      <p>Use the jumbled letters to make a real 5-letter word. Beat the clock to level up and refill the timer.</p>
      <p>If you enter a real word that's not the answer, you get +5 seconds (capped at 25s total) and correct letters lock in place.</p>
      <p>If the timer hits zero, we reveal the word and you lose a life.</p>
      <p><strong>25 seconds per word • 3 lives</strong></p>
      <p>Tip: ⤮ Shuffle letters • ⌫ Clear all</p>
      <div style="margin-top:12px; display:flex; gap:10px; justify-content:flex-end">
        <button id="playBtn" class="btn" type="button">Play</button>
      </div>
    </div>
  </div>

  <!-- Game Over Modal -->
  <div id="gameOverModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="gameOverTitle">
    <div class="dialog">
      <h2 id="gameOverTitle">Game Over</h2>
      <p id="gameOverBody">You reached level 0.</p>
      <div style="margin-top:12px; display:flex; gap:10px; justify-content:flex-end">
        <button id="tryAgainBtn" class="btn" type="button">try again ➜</button>
      </div>
    </div>
  </div>

  <!-- Loading / Retry Modal -->
  <div id="loadingModal" class="modal open" role="dialog" aria-modal="true" aria-labelledby="loadingTitle">
    <div class="dialog">
      <h2 id="loadingTitle">Loading word lists…</h2>
      <p id="loadingStatus">Fetching…</p>
      <div style="margin-top:12px; display:flex; gap:10px; justify-content:flex-end">
        <button id="retryBtn" class="btn" type="button" disabled>Retry</button>
      </div>
    </div>
  </div>

  <script>
    // ------------------------------
    // 1) Constants & State
    // ------------------------------
    const COUNTDOWN_SECONDS = 25;
    const STARTING_LIVES = 3;
    const TIME_BOOST_SECONDS = 5;
    const MAX_TIME_SECONDS = 25; // hard cap
    const TICK_MS = 100;

    let ANSWER_POOL = [];
    let ACCEPTED_SET = new Set();

    let answerWord = "";
    let bank = [];                 // [{ch, used} x 5]
    let current = Array(5).fill("");
    let locked = Array(5).fill(false);
    let placedIndex = Array(5).fill(null);

    let lives = STARTING_LIVES;
    let level = 1;
    let runStartAt = 0;
    let deadlineAt = 0; // performance.now() + 25_000
    let timerHandle = null;
    let lastAnnounceSec = null;
    let isAnimating = false;
    let inputsDisabled = false; // during reveal

    // DOM
    const elLivesPips = () => Array.from(document.querySelectorAll('.pip'));
    const livesText = document.getElementById('livesText');
    const levelEl = document.getElementById('level');
    const timerEl = document.getElementById('timer');
    const timerFill = document.getElementById('timerFill');
    const answerRow = document.getElementById('answerRow');
    const bankRow = document.getElementById('bankRow');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const clearBtn = document.getElementById('clearBtn');
    const announceEl = document.getElementById('announce');

    const introModal = document.getElementById('introModal');
    const playBtn = document.getElementById('playBtn');
    const gameOverModal = document.getElementById('gameOverModal');
    const gameOverBody = document.getElementById('gameOverBody');
    const tryAgainBtn = document.getElementById('tryAgainBtn');
    const loadingModal = document.getElementById('loadingModal');
    const loadingStatus = document.getElementById('loadingStatus');
    const retryBtn = document.getElementById('retryBtn');

    // ------------------------------
    // 2) Theme toggle (persist in sessionStorage)
    // ------------------------------
    const THEME_KEY = 'jumbl-theme';
    const themeToggle = document.getElementById('themeToggle');
    function applyTheme(theme){
      document.documentElement.classList.toggle('dark', theme === 'dark');
      themeToggle.innerHTML = theme === 'dark' ? sunSVG() : moonSVG();
    }
    function initTheme(){
      let theme = sessionStorage.getItem(THEME_KEY);
      if(!theme){ theme = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'; }
      applyTheme(theme);
    }
    themeToggle.addEventListener('click', () => {
      const isDark = document.documentElement.classList.toggle('dark');
      sessionStorage.setItem(THEME_KEY, isDark ? 'dark' : 'light');
      themeToggle.innerHTML = isDark ? sunSVG() : moonSVG();
    });
    function sunSVG(){
      return `<svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><circle cx="12" cy="12" r="4" stroke="currentColor" stroke-width="2"/><path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>`;
    }
    function moonSVG(){
      return `<svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" stroke="currentColor" stroke-width="2" fill="none"/></svg>`;
    }

    // ------------------------------
    // 3) Dynamic viewport vars
    // ------------------------------
    function setViewportVars(){
      const vv = window.visualViewport;
      const vw = vv ? vv.width : window.innerWidth;
      const vh = vv ? vv.height : window.innerHeight;
      document.documentElement.style.setProperty('--vw', vw + 'px');
      document.documentElement.style.setProperty('--vh', vh + 'px');
    }
    setViewportVars();
    if(window.visualViewport){
      visualViewport.addEventListener('resize', setViewportVars);
      visualViewport.addEventListener('scroll', setViewportVars);
    }
    window.addEventListener('orientationchange', setViewportVars);
    window.addEventListener('resize', setViewportVars);
    window.addEventListener('pageshow', setViewportVars);

    // ------------------------------
    // 4) Word list loading
    // ------------------------------
    async function loadWordLists(){
      try{
        loadingModal.classList.add('open');
        loadingStatus.textContent = 'Fetching…';
        retryBtn.disabled = true;

        const [aRes, gRes] = await Promise.all([
          fetch('answers.txt', { cache:'no-store' }),
          fetch('guesses.txt', { cache:'no-store' })
        ]);

        if(!aRes.ok || !gRes.ok) throw new Error('Network error');

        const [aText, gText] = await Promise.all([aRes.text(), gRes.text()]);
        const parse = (t) => t.split(/\r?\n/).map(s=>s.trim().toUpperCase()).filter(s=>/^[A-Z]{5}$/.test(s));
        const answers = parse(aText);
        const guesses = parse(gText);

        if(!answers.length || !guesses.length) throw new Error('Empty lists');

        ANSWER_POOL = answers;
        ACCEPTED_SET = new Set(guesses);

        loadingStatus.textContent = `Loaded ${answers.length} answers, ${guesses.length} guesses.`;
        setTimeout(()=> loadingModal.classList.remove('open'), 250);
        // After loading, show intro rules
        introModal.classList.add('open');
        playBtn.focus();
      }catch(err){
        loadingStatus.innerHTML = "Couldn't load files. Serve over HTTP and ensure <code>answers.txt</code> and <code>guesses.txt</code> sit beside <code>index.html</code>.";
        retryBtn.disabled = false;
      }
    }

    retryBtn.addEventListener('click', loadWordLists);
    playBtn.addEventListener('click', () => { introModal.classList.remove('open'); startRun(); });

    // ------------------------------
    // 5) Game flow helpers
    // ------------------------------
    function randInt(n){ return Math.floor(Math.random()*n); }
    function shuffleArr(arr){ for(let i=arr.length-1;i>0;i--){ const j=randInt(i+1); [arr[i], arr[j]]=[arr[j], arr[i]]; } return arr; }

    function buildBankFrom(word){
      const letters = word.split('');
      shuffleArr(letters);
      return letters.map(ch => ({ ch, used:false }));
    }

    function renderLives(){
      const pips = elLivesPips();
      pips.forEach((pip, i) => pip.classList.toggle('on', i < lives));
      livesText.textContent = `Lives: ${lives} of ${STARTING_LIVES}`;
    }

    function renderLevel(){ levelEl.textContent = `Level ${level}`; }

    function renderRows(){
      // Answer row
      answerRow.innerHTML = '';
      for(let i=0;i<5;i++){
        const d = document.createElement('div');
        d.className = 'tile' + (locked[i] ? ' locked' : '');
        d.textContent = current[i] || '';
        answerRow.appendChild(d);
      }
      // Bank row
      bankRow.innerHTML = '';
      bank.forEach((b, idx) => {
        const btn = document.createElement('button');
        btn.className = 'bank-btn';
        btn.type = 'button';
        btn.textContent = b.ch;
        btn.disabled = b.used || inputsDisabled;
        btn.setAttribute('aria-disabled', btn.disabled ? 'true' : 'false');
        btn.addEventListener('click', () => onLetterTap(idx));
        bankRow.appendChild(btn);
      });
    }

    function renderTimer(nowMs){
      const now = (typeof nowMs === 'number') ? nowMs : performance.now();
      const remainMs = Math.max(0, deadlineAt - now);
      const remainSec = remainMs / 1000;
      const pct = Math.max(0, Math.min(1, remainSec / COUNTDOWN_SECONDS));
      timerFill.style.width = (pct * 100).toFixed(2) + '%';
      timerEl.setAttribute('aria-valuenow', Math.ceil(remainSec).toString());

      const whole = Math.ceil(remainSec);
      if(whole !== lastAnnounceSec && whole % 1 === 0){
        announceEl.textContent = `${whole} seconds remaining`;
        lastAnnounceSec = whole;
      }
    }

    function startTimer(){
      stopTimer();
      deadlineAt = performance.now() + COUNTDOWN_SECONDS * 1000;
      renderTimer();
      timerHandle = setInterval(()=>{
        const now = performance.now();
        if(now >= deadlineAt){
          renderTimer(now);
          stopTimer();
          onTimeout();
        }else{
          renderTimer(now);
        }
      }, TICK_MS);
    }
    function stopTimer(){ if(timerHandle){ clearInterval(timerHandle); timerHandle = null; } }

    function addTime(seconds){
      const now = performance.now();
      const remain = Math.max(0, deadlineAt - now);
      const added = Math.min((remain + seconds*1000), MAX_TIME_SECONDS*1000);
      deadlineAt = now + added;
      renderTimer(now);
      announceEl.textContent = `Valid word — +${seconds} seconds (capped)`;
    }

    function startRun(){
      lives = STARTING_LIVES;
      level = 1;
      runStartAt = Date.now();
      renderLives();
      renderLevel();
      nextWord(false);
    }

    function nextWord(increment){
      if(increment) level++;
      renderLevel();
      answerWord = ANSWER_POOL[randInt(ANSWER_POOL.length)];
      bank = buildBankFrom(answerWord);
      current = Array(5).fill("");
      locked = Array(5).fill(false);
      placedIndex = Array(5).fill(null);
      inputsDisabled = false;
      renderRows();
      startTimer();
    }

    function onLetterTap(bankIndex){
      if(inputsDisabled || isAnimating) return;
      const b = bank[bankIndex];
      if(!b || b.used) return;

      // find next unlocked slot
      const slot = current.findIndex((ch, i) => !locked[i] && ch === '');
      if(slot === -1) return;

      current[slot] = b.ch;
      placedIndex[slot] = bankIndex;
      b.used = true;

      // pop animation on that tile
      const tile = answerRow.children[slot];
      tile.classList.remove('pop'); void tile.offsetWidth; tile.classList.add('pop');

      renderRows(); // re-render bank disabled state

      autoSubmitIfFull();
    }

    function onShuffle(){
      if(inputsDisabled) return;
      // shuffle only unused bank letters (keep used/locked positions visually stable)
      const unused = bank.map((b, i) => (!b.used ? { ch:b.ch, idx:i } : null)).filter(Boolean);
      const letters = unused.map(u=>u.ch);
      shuffleArr(letters);
      unused.forEach((u, k) => { bank[u.idx].ch = letters[k]; });
      bankRow.classList.remove('jiggle'); void bankRow.offsetWidth; bankRow.classList.add('jiggle');
      renderRows();
    }

    function onClearAll(){
      if(inputsDisabled) return;
      for(let i=0;i<5;i++){
        if(!locked[i] && current[i] !== ''){
          const bIdx = placedIndex[i];
          if(bIdx !== null && bank[bIdx]) bank[bIdx].used = false;
          current[i] = '';
          placedIndex[i] = null;
        }
      }
      renderRows();
    }

    function autoSubmitIfFull(){
      const filled = current.every((ch, i) => locked[i] || ch !== '');
      if(!filled) return;
      evaluateGuess(current.join(''));
    }

    function evaluateGuess(guess){
      if(isAnimating) return;
      if(guess === answerWord){
        // Correct
        stopTimer();
        celebrate();
        setTimeout(()=> nextWord(true), 420);
        return;
      }
      if(ACCEPTED_SET.has(guess)){
        // Valid but wrong -> +5s (capped), lock matches, clear others
        addTime(TIME_BOOST_SECONDS);
        for(let i=0;i<5;i++){
          if(current[i] === answerWord[i]){
            locked[i] = true;
          }else{
            // free bank index for this slot
            const bIdx = placedIndex[i];
            if(bIdx !== null && bank[bIdx]) bank[bIdx].used = false;
            current[i] = '';
            placedIndex[i] = null;
          }
        }
        renderRows();
        return;
      }
      // Invalid -> shake + clear non-locked
      answerRow.classList.remove('shake'); void answerRow.offsetWidth; answerRow.classList.add('shake');
      for(let i=0;i<5;i++){
        if(!locked[i] && current[i] !== ''){
          const bIdx = placedIndex[i];
          if(bIdx !== null && bank[bIdx]) bank[bIdx].used = false;
          current[i] = '';
          placedIndex[i] = null;
        }
      }
      renderRows();
    }

    function celebrate(){
      // motion-only pop on tiles
      for(let i=0;i<5;i++){
        const tile = answerRow.children[i];
        tile.classList.remove('pop'); void tile.offsetWidth; tile.classList.add('pop');
      }
    }

    function onTimeout(){
      lives = Math.max(0, lives - 1);
      renderLives();
      revealAndShudder(answerWord);
      if(lives > 0){
        setTimeout(()=> nextWord(true), 900);
      }else{
        setTimeout(()=> gameOver(), 900);
      }
    }

    function revealAndShudder(word){
      inputsDisabled = true;
      // Fill all slots with correct word
      for(let i=0;i<5;i++){
        current[i] = word[i];
        locked[i] = false; // irrelevant now
        placedIndex[i] = null;
      }
      renderRows();
      answerRow.classList.remove('shudder'); void answerRow.offsetWidth; answerRow.classList.add('shudder');
      announceEl.textContent = `Time’s up — the word was ${word}.`;
    }

    function gameOver(){
      stopTimer();
      inputsDisabled = true;
      const levelsCompleted = Math.max(0, level - 1);
      const runMs = Date.now() - runStartAt;
      const mm = String(Math.floor(runMs/60000)).padStart(2,'0');
      const ss = String(Math.floor((runMs%60000)/1000)).padStart(2,'0');
      gameOverBody.textContent = `You reached level ${levelsCompleted}. Time: ${mm}:${ss}`;
      gameOverModal.classList.add('open');
      tryAgainBtn.focus();
    }

    tryAgainBtn.addEventListener('click', () => { gameOverModal.classList.remove('open'); startRun(); });

    // ------------------------------
    // 6) Keyboard shortcuts (desktop)
    // ------------------------------
    document.addEventListener('keydown', (e) => {
      // ignore when modals open or during reveal
      if(introModal.classList.contains('open') || gameOverModal.classList.contains('open') || loadingModal.classList.contains('open') || inputsDisabled) return;

      const key = e.key.toUpperCase();
      if(key === ' '){ e.preventDefault(); onShuffle(); return; }
      if(key === 'BACKSPACE' || key === 'DELETE'){ e.preventDefault(); onClearAll(); return; }
      if(key.length === 1 && key >= 'A' && key <= 'Z'){
        // place leftmost matching unused bank entry into next unlocked slot
        const idx = bank.findIndex((b) => !b.used && b.ch === key);
        if(idx !== -1){ onLetterTap(idx); }
      }
    });

    // ------------------------------
    // 7) Wire up controls & init
    // ------------------------------
    shuffleBtn.addEventListener('click', onShuffle);
    clearBtn.addEventListener('click', onClearAll);

    initTheme();
    loadWordLists();
    renderLives();
    renderLevel();

  </script>
</body>
</html>