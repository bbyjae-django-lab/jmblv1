<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover"
  />
  <meta name="theme-color" content="#ffffff" id="theme-color" />
  <title>JUMBL</title>
  <style>
    /* =========================
       THEME & SIZING TOKENS
       ========================= */
    :root{
      /* Implemented exactly per spec */
      --tile: clamp(68px, 9.5vw, 84px);
      --gap: 16px;
      --row-gap: 18px;

      /* Palette */
      --bg: #FAF7F2;
      --fg: #222;
      --muted: #666;
      --accent: #EE7FB2;

      /* Tiles */
      --tile-bg: #FFFFFF;
      --shadow: 0 10px 24px rgba(0,0,0,.08);
      --inner: inset 0 1px 0 rgba(255,255,255,.35);

      /* Bank gradient */
      --bank-gradient: linear-gradient(135deg, #F6C58F 0%, #E8A6D8 100%);
    }
    [data-theme="dark"]{
      --bg: #0e0f13;
      --fg: #f6f6f6;
      --muted: #a1a1a1;
      --tile-bg: #1b1d24;
      --shadow: 0 10px 24px rgba(0,0,0,.40);
      --inner: inset 0 1px 0 rgba(255,255,255,.08);
    }

    /* =========================
       GLOBAL / LAYOUT
       ========================= */
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font: 16px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji;
      display: flex;
      justify-content: center;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    .app{
      width: min(520px, 100%);
      padding: calc(env(safe-area-inset-top) + 16px) 16px calc(env(safe-area-inset-bottom) + 24px);
      display: grid;
      grid-template-rows: auto auto 1fr auto;
      gap: 12px;
    }

    header{
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    h1{
      margin: 0;
      font-size: 22px;
      letter-spacing: 2px;
    }
    .theme-toggle{
      position: absolute;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 44px;
      height: 44px;
      border-radius: 12px;
      border: 0;
      background: none;
      color: var(--fg);
      font-size: 20px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .theme-toggle:active{ transform: translateY(-50%) scale(0.96); }

    .status{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      font-weight: 600;
      letter-spacing: .3px;
    }
    .status .left, .status .right{ width: 96px; }
    .status .center{ flex: 1; display: flex; justify-content: center; }
    .timer{ font-variant-numeric: tabular-nums; }

    .lives{ display: flex; gap: 6px; align-items: center; }
    .life{
      width: 14px; height: 14px;
      border-radius: 3px;
      background: #e9e9e9;
      box-shadow: var(--inner);
    }
    .life.on{ background: var(--accent); }

    .board{
      display: grid;
      justify-items: center;
      align-content: start;
      gap: 10px;
    }

    /* =========================
       ROWS (SPEC-EXACT SIZING)
       ========================= */
    .answer, .bank {
      display: inline-grid;
      grid-template-columns: repeat(5, var(--tile));
      gap: var(--gap);
      width: min-content;        /* grid = just tiles + gaps */
      margin-inline: auto;       /* center the block */
      align-items: start;        /* never stretch items vertically */
    }
    .answer { margin-block-end: var(--row-gap); }

    .slot, .letter{
      width: var(--tile);
      height: var(--tile);
      display: grid;
      place-items: center;
      border-radius: 16px;
      box-shadow: var(--shadow), var(--inner);
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    /* Answer tiles (bottom row) */
    .slot{ background: var(--tile-bg); }
    .slot.locked{
      outline: 2px solid rgba(238,127,178,.9);
      outline-offset: -2px;
    }

    /* Bank tiles (top row) */
    .letter{
      background: var(--bank-gradient);
      cursor: pointer;
    }
    .letter.used{ opacity: .25; pointer-events: none; filter: saturate(70%); }

    /* Letter typography */
    .char{
      font-weight: 800;
      font-size: clamp(22px, 3.2vw, 28px);
      letter-spacing: .5px;
      text-transform: uppercase;
    }
    .answer .char{ color: var(--accent); }     /* placed letters per spec */
    .letter .char{ color: #1b1b1b; }          /* bank letter color */

    /* Controls */
    .controls{
      display: flex;
      gap: 12px;
      justify-content: center;
      padding-top: 6px;
    }
    button.control{
      flex: 0 0 auto;
      min-width: 140px;
      height: 48px;
      border-radius: 16px;
      border: 0;
      box-shadow: var(--shadow);
      background: #fff;
      color: #111;
      font-weight: 700;
      letter-spacing: .3px;
      cursor: pointer;
    }
    [data-theme="dark"] button.control{ background: #242833; color: #fff; }
    button.control:active{ transform: scale(0.98); }
    button.control:disabled{ opacity: .5; }

    .footer{
      text-align: center;
      font-size: 12px;
      color: var(--muted);
      padding-top: 8px;
    }

    /* =========================
       MODALS
       ========================= */
    .modal{
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 24px;
      backdrop-filter: blur(8px);
      background: color-mix(in oklab, var(--bg), transparent 40%);
      z-index: 10;
    }
    .modal.show{ display: flex; }
    .dialog{
      width: min(520px, 94vw);
      border-radius: 20px;
      padding: 20px;
      background: var(--tile-bg);
      color: var(--fg);
      box-shadow: var(--shadow);
    }
    .dialog h2{ margin: 0 0 6px; }
    .dialog p{ margin: 6px 0 12px; color: var(--muted); }
    .dialog .actions{ display: flex; justify-content: flex-end; gap: 8px; }
    button.primary{
      background: var(--accent);
      color: #fff;
      border: 0;
      padding: 12px 16px;
      border-radius: 12px;
      font-weight: 700;
      cursor: pointer;
    }
    button.secondary{
      background: transparent;
      border: 0;
      padding: 12px 16px;
      border-radius: 12px;
      color: var(--fg);
      cursor: pointer;
    }

    /* =========================
       ANIMATIONS (GPU-friendly)
       ========================= */
    .pop{ animation: pop 180ms ease-out; }
    @keyframes pop{
      0%{ transform: scale(1); }
      40%{ transform: scale(1.08); }
      100%{ transform: scale(1); }
    }

    .shake{
      animation: shake 320ms cubic-bezier(.36,.07,.19,.97) both;
      transform: translate3d(0,0,0);
      backface-visibility: hidden;
      perspective: 1000px;
    }
    @keyframes shake{
      10%, 90% { transform: translateX(-2px); }
      20%, 80% { transform: translateX(4px); }
      30%, 50%, 70% { transform: translateX(-6px); }
      40%, 60% { transform: translateX(6px); }
    }

    .hidden{ display: none !important; }
    .visually-hidden{
      position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px;
      overflow: hidden; clip: rect(0,0,1px,1px); border: 0;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>JUMBL</h1>
      <button class="theme-toggle" aria-label="Toggle theme" id="themeToggle">ðŸŒ—</button>
    </header>

    <div class="status">
      <div class="left">Level <span id="level">1</span></div>
      <div class="center">
        <div class="lives" id="lives"></div>
      </div>
      <div class="right timer" id="timer">00:25</div>
    </div>

    <div class="board">
      <!-- Top row: Bank -->
      <div class="bank" id="bank" aria-label="Letter bank"></div>
      <!-- Bottom row: Answer -->
      <div class="answer" id="answer" aria-label="Answer slots"></div>
    </div>

    <div class="controls">
      <button class="control" id="shuffleBtn" type="button">â¤® Shuffle</button>
      <button class="control" id="backBtn" type="button">âŒ« Back</button>
    </div>

    <div class="footer">Single-file prototype â€¢ serve over HTTP to load word lists</div>
  </div>

  <!-- Intro modal -->
  <div class="modal" id="introModal" aria-modal="true" role="dialog">
    <div class="dialog">
      <h2>Welcome to JUMBL</h2>
      <p>Tap letters to build the 5-letter word. Fill all slots to submit automatically.</p>
      <ul style="margin: 0 0 12px 18px; color: var(--muted);">
        <li>3 lives. Wrong <em>valid</em> word: -1 life &amp; correct letters lock.</li>
        <li>Invalid word: shake &amp; clear (no life lost).</li>
        <li>Timer 25s. At 0: -1 life, bank reshuffles, locked letters stay.</li>
      </ul>
      <div class="actions">
        <button class="primary" id="playBtn" type="button">Play â–¶</button>
      </div>
    </div>
  </div>

  <!-- Game Over modal -->
  <div class="modal" id="gameOverModal" aria-modal="true" role="dialog">
    <div class="dialog">
      <h2>no more lives</h2>
      <p id="runSummary"></p>
      <div class="actions">
        <button class="primary" id="retryBtn" type="button">try again âžœ</button>
      </div>
    </div>
  </div>

  <script>
    (() => {
      'use strict';

      /* =========================
         DATA & STATE
         ========================= */
      let ANSWERS = [];
      let ACCEPTED_SET = new Set();

      const STATE = {
        answerWord: '',
        locked: [false,false,false,false,false],
        current: ['', '', '', '', ''],
        placedIndex: [null,null,null,null,null], // bank tile id per slot
        lives: 3,
        level: 1,
        deadline: 0,    // timestamp ms
        timerId: null,  // interval id
        bank: [],       // [{id, ch, used}]
        runStart: 0     // timestamp when a run begins
      };

      let UNIQUE_ID = 1;

      /* =========================
         HELPERS
         ========================= */
      const qs  = (s, r=document) => r.querySelector(s);
      const qsa = (s, r=document) => Array.from(r.querySelectorAll(s));
      const choice = (arr) => arr[(Math.random() * arr.length) | 0];

      function shuffle(arr){
        for(let i = arr.length - 1; i > 0; i--){
          const j = (Math.random() * (i+1)) | 0;
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      function formatTime(ms){
        const total = Math.max(0, Math.ceil(ms/1000));
        const m = Math.floor(total / 60);
        const s = total % 60;
        return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
      }
      const now = () => Date.now();
      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

      function playPop(){
        const el = qs('#answer');
        el.classList.remove('pop');
        void el.offsetWidth;
        el.classList.add('pop');
      }
      function playShake(){
        const el = qs('#answer');
        el.classList.remove('shake');
        void el.offsetWidth;
        el.classList.add('shake');
        setTimeout(() => el.classList.remove('shake'), 360);
      }

      /* =========================
         LOAD WORD LISTS
         ========================= */
      async function loadWordLists(){
        const parseList = (text) => {
          const out = [];
          for (const raw of text.split(/\r?\n/)) {
            const line = raw.trim();
            if (!line) continue;
            const word = line.toUpperCase().replace(/[^A-Z]/g, '');
            if (word.length === 5) out.push(word);
          }
          return out;
        };

        const [answersResp, guessesResp] = await Promise.all([
          fetch('answers.txt', { cache: 'no-store' }),
          fetch('guesses.txt', { cache: 'no-store' })
        ]);
        if (!answersResp.ok) throw new Error('Failed to load answers.txt');
        if (!guessesResp.ok) throw new Error('Failed to load guesses.txt');

        const answersText = await answersResp.text();
        const guessesText = await guessesResp.text();

        ANSWERS = parseList(answersText);
        const accepted = parseList(guessesText);
        ACCEPTED_SET = new Set(accepted);

        if (!Array.isArray(ANSWERS) || ANSWERS.length === 0) {
          throw new Error('answers.txt appears empty or invalid.');
        }
        // Ensure all answers are in accepted set (safety)
        for (const a of ANSWERS) {
          if (!ACCEPTED_SET.has(a)) ACCEPTED_SET.add(a);
        }
      }

      /* =========================
         GAME LIFECYCLE
         ========================= */
      async function boot(){
        try{
          applySavedTheme();
          await loadWordLists();
          showModal('introModal', true);
        }catch(err){
          alert('Error loading word lists: ' + err.message + '\nServe files over HTTP and place answers.txt & guesses.txt alongside index.html.');
          console.error(err);
        }
      }

      function startGame(){
        resetStateForRun();
        pickNewAnswer();
        renderAll();
        startTimer(true);
      }

      function resetStateForRun(){
        STATE.lives = 3;
        STATE.level = 1;
        STATE.runStart = now();
        resetRoundState();
      }

      function resetRoundState(){
        STATE.locked = [false,false,false,false,false];
        STATE.current = ['', '', '', '', ''];
        STATE.placedIndex = [null,null,null,null,null];
        STATE.bank = [];
        UNIQUE_ID = 1;
      }

      function pickNewAnswer(){
        STATE.answerWord = choice(ANSWERS);
        buildBankFromAnswer();
      }

      function buildBankFromAnswer(){
        const letters = STATE.answerWord.split('');
        const objs = letters.map(ch => ({ id: UNIQUE_ID++, ch, used: false }));
        shuffle(objs);
        STATE.bank = objs;
      }

      function nextLevel(){
        STATE.level += 1;
        resetRoundState();
        pickNewAnswer();
        renderAll();
        startTimer(true);
      }

      /* =========================
         TIMER
         ========================= */
      function startTimer(fullRefill){
        if (STATE.timerId) clearInterval(STATE.timerId);
        const full = 25000; // 25s
        const remain = fullRefill ? full : Math.max(0, STATE.deadline - now());
        STATE.deadline = now() + (fullRefill ? full : remain);
        renderTimer();
        STATE.timerId = setInterval(tick, 200);
      }

      function tick(){
        const msLeft = STATE.deadline - now();
        if (msLeft <= 0){
          clearInterval(STATE.timerId);
          // Time out: -1 life, reshuffle unused bank letters, keep locks, refill timer
          decrementLife();
          if (STATE.lives <= 0){
            gameOver();
            return;
          }
          reshuffleUnusedBank();
          renderAll();
          STATE.deadline = now() + 25000;
          renderTimer();
          STATE.timerId = setInterval(tick, 200);
          return;
        }
        renderTimer(msLeft);
      }

      function renderTimer(msLeft = STATE.deadline - now()){
        qs('#timer').textContent = formatTime(msLeft);
      }

      function decrementLife(){
        STATE.lives = clamp(STATE.lives - 1, 0, 3);
        renderLives();
      }

      /* =========================
         RENDER
         ========================= */
      function renderAll(){
        renderStatus();
        renderRows();
        renderControls();
      }

      function renderStatus(){
        qs('#level').textContent = STATE.level;
        renderLives();
        renderTimer();
      }

      function renderLives(){
        const livesEl = qs('#lives');
        livesEl.innerHTML = '';
        for (let i = 0; i < 3; i++){
          const div = document.createElement('div');
          div.className = 'life' + (i < STATE.lives ? ' on' : '');
          livesEl.appendChild(div);
        }
      }

      function renderRows(){
        // Answer row
        const ansEl = qs('#answer');
        ansEl.innerHTML = '';
        for (let i = 0; i < 5; i++){
          const slot = document.createElement('div');
          slot.className = 'slot' + (STATE.locked[i] ? ' locked' : '');
          const ch = STATE.current[i];
          if (ch){
            const span = document.createElement('span');
            span.className = 'char';
            span.textContent = ch;
            slot.appendChild(span);
          }
          ansEl.appendChild(slot);
        }

        // Bank row
        const bankEl = qs('#bank');
        bankEl.innerHTML = '';
        STATE.bank.forEach((obj, idx) => {
          const tile = document.createElement('button');
          tile.className = 'letter' + (obj.used ? ' used' : '');
          tile.type = 'button';
          tile.setAttribute('aria-label', obj.used ? `${obj.ch} used` : `Use ${obj.ch}`);
          tile.addEventListener('click', () => onLetterTap(idx));
          const span = document.createElement('span');
          span.className = 'char';
          span.textContent = obj.ch;
          tile.appendChild(span);
          bankEl.appendChild(tile);
        });
      }

      function renderControls(){
        // Enable backspace only if a non-locked slot has a letter
        const hasPlaced = STATE.current.some((ch, i) => ch && !STATE.locked[i]);
        qs('#backBtn').disabled = !hasPlaced;
      }

      /* =========================
         INPUT HANDLERS
         ========================= */
      function onLetterTap(bankIdx){
        const tile = STATE.bank[bankIdx];
        if (!tile || tile.used) return;

        const slotIdx = findNextFreeSlot();
        if (slotIdx === -1) return;

        placeLetter(slotIdx, bankIdx);
        renderAll();
        autoSubmitIfFull();
      }

      function findNextFreeSlot(){
        for (let i = 0; i < 5; i++){
          if (!STATE.locked[i] && !STATE.current[i]) return i;
        }
        return -1;
      }

      function placeLetter(slotIdx, bankIdx){
        const tile = STATE.bank[bankIdx];
        STATE.current[slotIdx] = tile.ch;
        STATE.placedIndex[slotIdx] = tile.id;
        tile.used = true;
      }

      function onBackspace(){
        for (let i = 4; i >= 0; i--){
          if (!STATE.locked[i] && STATE.current[i]){
            const id = STATE.placedIndex[i];
            const bankIdx = STATE.bank.findIndex(o => o.id === id);
            if (bankIdx !== -1) STATE.bank[bankIdx].used = false;
            STATE.current[i] = '';
            STATE.placedIndex[i] = null;
            renderAll();
            break;
          }
        }
      }

      function onShuffle(){
        refreshShuffle();
        renderRows();
      }

      function refreshShuffle(){
        // Shuffle only unused bank tiles; keep used tiles in place
        const unused = STATE.bank.filter(o => !o.used);
        shuffle(unused);
        const newBank = [];
        let ptr = 0;
        for (const b of STATE.bank){
          if (b.used) newBank.push(b);
          else newBank.push(unused[ptr++]);
        }
        STATE.bank = newBank;
      }

      function reshuffleUnusedBank(){
        refreshShuffle();
      }

      function autoSubmitIfFull(){
        // Require all 5 positions filled (locked count + current filled == 5)
        const filledCount = STATE.current.filter(Boolean).length + STATE.locked.filter(Boolean).length;
        if (filledCount !== 5) return;

        const guess = STATE.current.map((ch, i) => ch || (STATE.locked[i] ? STATE.answerWord[i] : '')).join('');
        evaluateGuess(guess);
      }

      function evaluateGuess(guess){
        const answer = STATE.answerWord;

        if (guess === answer){
          playPop();
          setTimeout(() => nextLevel(), 220);
          return;
        }

        if (ACCEPTED_SET.has(guess)){
          // Valid but wrong: -1 life; lock correct positions; clear rest
          decrementLife();
          if (STATE.lives <= 0){
            gameOver();
            return;
          }
          lockCorrectFrom(guess);
          renderAll();
          return;
        }

        // Invalid: shake + clear (no life lost)
        playShake();
        for (let i = 0; i < 5; i++){
          if (!STATE.locked[i] && STATE.current[i]){
            const id = STATE.placedIndex[i];
            const bankIdx = STATE.bank.findIndex(o => o.id === id);
            if (bankIdx !== -1) STATE.bank[bankIdx].used = false;
            STATE.current[i] = '';
            STATE.placedIndex[i] = null;
          }
        }
        renderAll();
      }

      function lockCorrectFrom(guess){
        for (let i = 0; i < 5; i++){
          if (guess[i] === STATE.answerWord[i]){
            STATE.locked[i] = true; // keep letter in place and bank tile "used"
          } else {
            if (!STATE.locked[i] && STATE.current[i]){
              const id = STATE.placedIndex[i];
              const bankIdx = STATE.bank.findIndex(o => o.id === id);
              if (bankIdx !== -1) STATE.bank[bankIdx].used = false;
              STATE.current[i] = '';
              STATE.placedIndex[i] = null;
            }
          }
        }
      }

      function gameOver(){
        if (STATE.timerId) clearInterval(STATE.timerId);
        const durationMs = now() - STATE.runStart;
        const mins = Math.floor(durationMs / 60000);
        const secs = Math.floor((durationMs % 60000) / 1000);
        const runtime = `${mins}m ${secs}s`;
        qs('#runSummary').textContent = `Run time: ${runtime} Â· Levels completed: ${STATE.level - 1}`;
        showModal('gameOverModal', true);
      }

      /* =========================
         MODALS & THEME
         ========================= */
      function showModal(id, show=true){
        const m = qs('#' + id);
        m.classList.toggle('show', show);
      }

      function applySavedTheme(){
        const stored = localStorage.getItem('jumbl-theme');
        const theme = stored === 'dark' ? 'dark' : 'light';
        setTheme(theme);
      }
      function setTheme(theme){
        document.body.setAttribute('data-theme', theme);
        const themeColor = theme === 'dark' ? '#0e0f13' : '#ffffff';
        qs('#theme-color').setAttribute('content', themeColor);
      }
      function toggleTheme(){
        const cur = document.body.getAttribute('data-theme') || 'light';
        const next = cur === 'light' ? 'dark' : 'light';
        setTheme(next);
        localStorage.setItem('jumbl-theme', next);
      }

      /* =========================
         EVENTS
         ========================= */
      window.addEventListener('load', boot);
      qs('#themeToggle').addEventListener('click', toggleTheme);
      qs('#playBtn').addEventListener('click', () => { showModal('introModal', false); startGame(); });
      qs('#retryBtn').addEventListener('click', () => { showModal('gameOverModal', false); startGame(); });
      qs('#shuffleBtn').addEventListener('click', onShuffle);
      qs('#backBtn').addEventListener('click', onBackspace);

      // Optional: keep taps snappy on iOS
      qsa('button').forEach(b => b.addEventListener('touchend', () => {}, { passive: true }));
    })();
  </script>
</body>
</html>
