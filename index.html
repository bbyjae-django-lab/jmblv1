<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="utf-8" />
 <meta
  name="viewport"
  content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content"
/>
 <meta name="apple-mobile-web-app-capable" content="yes" />
 <title>JUMBL</title>
 <link rel="preload" as="font" href="fonts/Dangrek-Regular.woff2" type="font/woff2" crossorigin>
 <style>
/* Stylish — self-hosted (Regular only) */
@font-face{
  font-family: 'Dangrek-Regular';
  src: url('fonts/Dangrek-Regular.woff2') format('woff2');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

   /* ------------------------------------------------------
      0) Base / Theme / Resets — flat, monochrome, no shadows
      ------------------------------------------------------ */
   :root{
     color-scheme: light dark; /* keep system UI in sync */
     /* Light (default) */
     --bg:#FFFFFF; --fg:#000000; --muted:rgba(0,0,0,.60); --track:rgba(0,0,0,.12);
     --tile-bg:#FFFFFF; --tile-fg:#000000; --btn-bg:#FFFFFF; --btn-fg:#000000;
     --border:rgba(0,0,0,.15); --radius:12px;
     /* Buttons now reuse the tile elevation so everything matches the answer boxes */
      --btn-shadow:        var(--tile-shadow);
      /* Hover stays under the gap (<= 10px blur) so neighbors don’t “bridge” */
      --btn-shadow-hover:  0 4px 9px rgba(0,0,0,.14), 0 2px 5px rgba(0,0,0,.12), 0 1px 0 rgba(255,255,255,.70) inset;
      --btn-shadow-pressed:0 2px 4px rgba(0,0,0,.22) inset, 0 1px 2px rgba(0,0,0,.18);
      --btn-shadow-disabled:none;
      /* Tile elevation tokens (light) — keep blur <= var(--gap) to avoid bridging */
      --tile-shadow-empty: 0 2px 6px rgba(0,0,0,.08), 0 1px 0 rgba(255,255,255,.65) inset;
      --tile-shadow: 0 4px 9px rgba(0,0,0,.14), 0 2px 5px rgba(0,0,0,.12), 0 1px 0 rgba(255,255,255,.70) inset;
      
     /* layout clamps */
     --maxw:600px; /* app max width */
     --gap:10px;   /* tile/bank gap */
     --stack-tight: clamp(6px, 1.3vh, 12px);
   }
   html.dark{
     /* Dark */
     --bg:#000000; --fg:#FFFFFF; --muted:rgba(255,255,255,.70); --track:rgba(255,255,255,.15);
     --tile-bg:#000000; --tile-fg:#FFFFFF; --btn-bg:#000000; --btn-fg:#FFFFFF;
     --border:rgba(255,255,255,.20);
     --btn-shadow:        var(--tile-shadow);
      --btn-shadow-hover:  0 4px 9px rgba(0,0,0,.70), 0 2px 5px rgba(0,0,0,.60), 0 1px 0 rgba(255,255,255,.10) inset;
      --btn-shadow-pressed:0 2px 6px rgba(0,0,0,.65) inset, 0 1px 2px rgba(0,0,0,.55);
      --btn-shadow-disabled:none;
      /* Tile elevation tokens (dark) — darker drop, faint inner sheen */
      --tile-shadow-empty: 0 2px 6px rgba(0,0,0,.65), 0 1px 0 rgba(255,255,255,.08) inset;
      --tile-shadow: 0 4px 9px rgba(0,0,0,.70), 0 2px 5px rgba(0,0,0,.60), 0 1px 0 rgba(255,255,255,.10) inset;
   }


   *, *::before, *::after{ box-sizing: border-box; }
   html, body{ height:100%; }
   body{
     margin:0;
     font-family: "Dangrek-Regular", system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
     background:var(--bg);
     color:var(--fg);
     -webkit-text-size-adjust:100%;
     overflow-x:hidden;
   }
   /* No rubber-banding/overscroll at the page level */
    html, body{ overscroll-behavior: none; }

    .row, .bank, .btn-letter, .tile { touch-action: none; }

    /* Background SVG animation host */
    #bgSvg { z-index: 0; opacity: 0.55; }     /* subtle by default */
    html.dark #bgSvg { opacity: 0.55; }       /* a touch softer in dark mode */

    /* Respect reduced motion */
    @media (prefers-reduced-motion: reduce){
      #bgSvg .out-top,
      #bgSvg .in-top,
      #bgSvg .out-bottom,
      #bgSvg .in-bottom { animation: none !important; }
    }

   :focus{ outline: auto; }
   :focus:not(:focus-visible){ outline: none; }
   :where(button,[role="button"],a,input,select,textarea):focus-visible{
    outline: none !important;
    box-shadow: none;
   }
   a, button{ -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
  html, body, #app, .overlay, .dialog { touch-action: none; }
   button{
     font:inherit; color:inherit;
     background:var(--btn-bg);
     border:none;
     border-radius: var(--radius);
     padding:1rem 1rem;
     cursor:pointer;
   }
   button:disabled{ opacity:.35; cursor: default; }


   /* Disable text selection/callouts inside the play area */
   .app, .app *:not(input):not(textarea){
     -webkit-user-select: none; user-select: none; -webkit-touch-callout: none;
   }
   /* Also disable text selection/callouts inside modals */
   .dialog, .dialog *:not(input):not(textarea){
     -webkit-user-select: none; user-select: none; -webkit-touch-callout: none;
   }


   /* ------------------------------
      1) App shell & safe-area insets
      ------------------------------ */
   .app{
    width: min(100vw, var(--maxw));


     min-height: 100vh;               /* fallback */
     height: 100dvh;                  /* modern browsers */
     margin: 0 auto;
     display:flex; flex-direction:column;


     /* Safe-area aware side padding + base margin */
     padding:
       calc(env(safe-area-inset-top) + 16px)
       max(12px, calc(env(safe-area-inset-right) + 12px))
       calc(env(safe-area-inset-bottom) + 18px)
       max(12px, calc(env(safe-area-inset-left) + 12px));


     overflow: hidden;                /* no scroll bounce */
     overscroll-behavior: none;
     gap: 16px;
      position: relative;       /* new */
      z-index: 1;
   }

   /* Hide all UI except the header during pre-game or while any modal is open */
   .app.pre > :not(.header),
   .app.masked > :not(.header){ display:none !important; }


   /* ------------------------------
      2) Header (3-col grid)
      ------------------------------ */
   .header{ display:grid; grid-template-columns: 1fr 1fr 1fr; align-items:center; }
   .title{ text-align:center; font-weight:400; letter-spacing:.08em; font-size:3.5em; position:relative; z-index:3; opacity:1; mix-blend-mode:normal; }
   .theme-wrap{ justify-self:end; }
   .icon{ width:28px; height:28px; display:block; } 
   .icon svg{ width:100%; height:100%; display:block; }
   .theme-bottom{ display:flex; justify-content:center; }

   /* ------------------------------
      3) Lives, Score, Timer
      ------------------------------ */
   .lives{ display:flex; justify-content:center; gap:8px; }
   .pip{ width:28px; aspect-ratio:1/1; border:1px solid var(--border); border-radius:6px; background: transparent; }
   .pip.off{ opacity:.32; }
   .lives .pip:not(.off){ background: var(--fg); }

   .score{  text-align:center; font-size:17px; font-weight:400; color:var(--muted); }

   .timer-card{ border:none; padding:0; background:transparent; border-radius:0; }
   .timer-rail{ position:relative; height:14px; border-radius:9999px; background:var(--track); overflow:hidden; }
   .timer-fill{ position:absolute; inset:0; transform-origin:left center; transform: scaleX(1); background:var(--fg); transition: transform 100ms linear; }

   .header{ margin-top: 36px; margin-bottom: 26px; }
   .lives{  margin-bottom: 4px; }
   .score{  margin-top: 4px; margin-bottom: 4px; }
   .timer-card{ margin-top: 4px; margin-bottom: 2px; }
   .row{ margin-top: 2px; margin-bottom: 2px; }
   .bank{ margin-top: 2px; margin-bottom: 2px; }
   .controls{ margin-top: 2px; margin-bottom: 4px; }
   .theme-bottom{ margin-top: 4px; }


   /* ------------------------------
      4) Squares: Answer row & Letter bank
      ------------------------------ */
   .row, .bank{ display:grid; grid-template-columns: repeat(5, minmax(0, 1fr)); gap: var(--gap); }
   .tile, .btn-letter{
     aspect-ratio:1/1;
     min-inline-size:64px;
     border:1px solid var(--border); border-radius: var(--radius);
     background: var(--tile-bg); color:var(--tile-fg);
     display:flex; align-items:center; justify-content:center; /* older iOS centering */
     line-height:1;                                             /* avoid vertical bias */
     font-weight:400;
     font-size: clamp(24px, 8.5vw, 36px);  /* slightly larger */
     user-select:none;
   }
   /* Base tile styling */
    .tile{ 
      background: var(--tile-bg);
      /* Individual, cozy elevation per box */
      box-shadow: var(--tile-shadow-empty);
      transition: box-shadow 140ms ease, transform 120ms ease;
    }

    /* Filled tiles stand out a touch more than empty slots */
    .tile:not(.empty){
      box-shadow: var(--tile-shadow);
    }

    /* Empty tiles remain visible but subtler */
    .tile.empty{
      color: var(--muted);
      box-shadow: var(--tile-shadow-empty);
    }

   .btn-letter{ background:var(--btn-bg); }
   .btn-letter[aria-pressed="true"], .btn-letter.used{ opacity:.32; }


   /* ------------------------------
      5) Controls
      ------------------------------ */
      .controls{ display:grid; grid-template-columns: 1fr 1fr; gap: var(--gap); }
      .controls button{ width:100%; position:relative; z-index:2; background:var(--btn-bg); }
      button.press, .btn-letter.press{
        transform: scale(.96);
        transition: transform 120ms ease, box-shadow 140ms ease;}
      .controls button{ font-weight:400; }
      .card .actions button{ font-weight:400; border-radius: calc(var(--radius) + 2px); }
      .theme-bottom{ display:flex; justify-content:center; }

   /* 5b) Raised buttons — applied once to all buttons except the theme icon */
    :where(button):not(#themeBtn){
      border: 1px solid var(--border);
      border-radius: var(--radius);
      background: var(--btn-bg);
      box-shadow: var(--btn-shadow);
      transition: transform 120ms ease, box-shadow 140ms ease, filter 140ms ease;
    }

    /* Desktop hover lift */
    @media (hover:hover) and (pointer:fine){
      :where(button):not(#themeBtn):hover{
        box-shadow: var(--btn-shadow-hover);
      }
    }

    /* Pressed state: slight dip + pressed shadow */
    :where(button):not(#themeBtn).press{
      transform: translateY(1px) scale(.96); /* complements the global .press scale */
      box-shadow: var(--btn-shadow-pressed);
    }

    /* Disabled buttons lose elevation */
    :where(button):disabled{
      box-shadow: var(--btn-shadow-disabled);
    }

    /* Letter-bank specifics: “used” or aria-pressed behaves like disabled */
    .btn-letter[aria-pressed="true"],
    .btn-letter.used{
      box-shadow: var(--btn-shadow-disabled);
    }

/* Keep the theme icon flat by design (explicitly guard it) */
#themeBtn{ box-shadow: none !important; }

   /* Invisible button: keep 48×48 touch target, show only the icon */
  #themeBtn{
    display:inline-flex; align-items:center; justify-content:center;
    width:48px; height:48px; padding:0;
    background:transparent;     /* no fill */
    border:none;                /* no border */
    box-shadow:none;            /* in case a UA adds one */
    border-radius:0;            /* not visible, but avoids ghost corners */
    color:var(--fg);            /* drives the SVG icon color */
  }
  /* Remove focus outline on this control only (keep it elsewhere) */
  #themeBtn:focus,
  #themeBtn:focus-visible{ outline:none; }

  #themeIcon{
  width:28px; height:28px; display:block; pointer-events:none; }

   /* ------------------------------
      6) Spacer to aid tall screens
      ------------------------------ */
   .spacer{ flex:1 1 auto; }


   /* ------------------------------
      7) Animations (motion-only) & reduced-motion
      ------------------------------ */
   @keyframes shake{ 0%,100%{transform:translateX(0)} 20%{transform:translateX(-6px)} 40%{transform:translateX(6px)} 60%{transform:translateX(-4px)} 80%{transform:translateX(4px)} }
   @keyframes jiggle{ 0%,100%{ transform:rotate(0) } 25%{ transform:rotate(-2deg) } 75%{ transform:rotate(2deg) } }
   @keyframes pop{ 0%{ transform:scale(1) } 50%{ transform:scale(1.075) } 100%{ transform:scale(1) } }


   .shake{ animation: shake .22s linear; }
   .jiggle{ animation: jiggle .26s ease-in-out; }
   .pop{ animation: pop .6s ease; }
   /* Soft variants */
   @keyframes shakeSoft{ 0%,100%{ transform:translateX(0) } 20%{ transform:translateX(-3px) } 40%{ transform:translateX(3px) } 60%{ transform:translateX(-2px) } 80%{ transform:translateX(2px) } }
   .shake-soft{ animation: shakeSoft .22s linear; }
   @keyframes popSoft{ 0%{ transform:scale(1) } 50%{ transform:scale(1.03) } 100%{ transform:scale(1) } }
   .pop-soft{ animation: popSoft .45s ease; }

   /* Even subtler shake for the timer (≈30% less movement than shake-soft) */
  @keyframes shakeTiny{
    0%,100%{ transform:translateX(0) }
    20%{ transform:translateX(-2px) }  /* 70% of 3px */
    40%{ transform:translateX( 2px) }
    60%{ transform:translateX(-1px) }  /* 70% of 2px */
    80%{ transform:translateX( 1px) }
  }
  .shake-tiny{ animation: shakeTiny .46s linear; }

   /* Performance hints for smooth transforms */
   .row > .tile, .bank > .btn-letter { will-change: transform; contain: layout paint; }
   .timer-rail { will-change: transform; contain: layout paint; }

   @media (prefers-reduced-motion: reduce){
     .shake, .jiggle, .pop{ animation-duration: .01s; }
     .shake-soft, .pop-soft, .shake-tiny{ animation-duration: .01s; }
     .timer-fill{ transition: none; }
   }

   /* Answer bar press: transform on the row (composes with tile animations) */
.row.press-row {
  transform: translateY(1px) scale(.98);
  transition: transform 120ms ease;
}

/* Keep the per-tile shadow change only */
.row.press-row > .tile {
  box-shadow: var(--btn-shadow-pressed);
  transition: box-shadow 140ms ease;
}


    @media (prefers-reduced-motion: reduce){
      .row.press-row > .tile { transform: none; }
    }

   /* ------------------------------
      8) Modals (Intro, Game Over, Loading/Retry)
      ------------------------------ */
   .overlay{ position:fixed; inset:0; background: rgba(0,0,0,.55); display:none; z-index: 1000;}
   .overlay[aria-hidden="false"]{ display:block; }
   .dialog{ position:fixed; inset:0; display:none; place-items:center; z-index: 1001;}
   .dialog[aria-hidden="false"]{ display:grid; pointer-events:auto; }
   .card{ width:min(92vw, 520px); background:var(--bg); color:var(--fg); border:1px solid var(--border); border-radius:16px; padding:20px; box-shadow:none; }
   .card h2{ margin:0 0 10px; letter-spacing:.06em; }
   .card p{ margin:.5rem 0; color:var(--muted); }
   .card .actions{ display:flex; gap:10px; justify-content:flex-end; margin-top:16px; }


   /* ------------------------------
      9) Visually-hidden for a11y
      ------------------------------ */
   .sr-only{
     position:absolute; width:1px; height:1px; padding:0; margin:-1px;
     overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0;
   }
 </style>
</head>
<body>
    <!-- Background SVG animation (non-interactive) -->
    <svg id="bgSvg" aria-hidden="true" focusable="false" role="presentation"
         preserveAspectRatio="xMidYMid slice" viewBox="10 10 80 80"
         style="position:fixed;top:0;left:0;width:100%;height:100dvh;pointer-events:none;">
      <defs>
        <style>
          @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
          .out-top    { animation: rotate 20s linear infinite; transform-origin: 13px 25px; }
          .in-top     { animation: rotate 10s linear infinite; transform-origin: 13px 25px; }
          .out-bottom { animation: rotate 25s linear infinite; transform-origin: 84px 93px; }
          .in-bottom  { animation: rotate 15s linear infinite; transform-origin: 84px 93px; }
        </style>
      </defs>
      <path fill="#9b5de5" class="out-top"
            d="M37-5C25.1-14.7,5.7-19.1-9.2-10-28.5,1.8-32.7,31.1-19.8,49c15.5,21.5,52.6,22,67.2,2.3C59.4,35,53.7,8.5,37-5Z"/>
      <path fill="#f15bb5" class="in-top"
            d="M20.6,4.1C11.6,1.5-1.9,2.5-8,11.2-16.3,23.1-8.2,45.6,7.4,50S42.1,38.9,41,24.5C40.2,14.1,29.4,6.6,20.6,4.1Z"/>
      <path fill="#00bbf9" class="out-bottom"
            d="M105.9,48.6c-12.4-8.2-29.3-4.8-39.4.8-23.4,12.8-37.7,51.9-19.1,74.1s63.9,15.3,76-5.6c7.6-13.3,1.8-31.1-2.3-43.8C117.6,63.3,114.7,54.3,105.9,48.6Z"/>
      <path fill="#00f5d4" class="in-bottom"
            d="M102,67.1c-9.6-6.1-22-3.1-29.5,2-15.4,10.7-19.6,37.5-7.6,47.8s35.9,3.9,44.5-12.5C115.5,92.6,113.9,74.6,102,67.1Z"/>
    </svg>
  
    <div id="app" class="app pre" aria-live="polite">  
   <!-- Header -->
   <header class="header">
     <div></div>
     <div class="title" aria-hidden="true">JUMBL</div>
     <div class="theme-wrap"></div>
   </header>


   <!-- Lives -->
   <div id="lives" class="lives" aria-label="Lives" aria-live="polite"></div>
   <!-- Score -->
   <div id="score" class="score" aria-live="polite">Score: 0</div>


   <!-- Timer -->
   <section class="timer-card">
     <div id="timerRail" class="timer-rail" role="progressbar" aria-label="Time remaining (seconds)" aria-valuemin="0" aria-valuemax="25" aria-valuenow="25">
       <div id="timerFill" class="timer-fill"></div>
     </div>
     <span id="srSeconds" class="sr-only" aria-live="polite"></span>
   </section>


   <!-- Answer row above Letter bank -->
   <section id="answerRow" class="row" aria-label="Your guess"></section>
   <section id="bank" class="bank" aria-label="Letter bank"></section>


   <!-- Controls -->
   <div class="controls">
     <button id="shuffleBtn" type="button" aria-label="Shuffle letters">Shuffle</button>
     <button id="clearBtn" type="button" aria-label="Clear all">Clear</button>
   </div>


   <div class="theme-bottom">
     <button id="themeBtn" class="icon" aria-label="Toggle theme" title="Toggle theme">
       <svg id="themeIcon" viewBox="0 0 24 24" aria-hidden="true"></svg>
     </button>
   </div>


   <div class="spacer" aria-hidden="true"></div>


   <!-- A11y announcer for granular updates (letters placed, etc.) -->
   <div id="announcer" class="sr-only" aria-live="polite"></div>
 </div>


 <!-- Overlay + Dialog (reused for all modals) -->
 <div id="overlay" class="overlay" aria-hidden="true"></div>
 <div id="dialog" class="dialog" aria-hidden="true" aria-modal="true" role="dialog" aria-labelledby="dialogTitle">
   <div class="card" role="document">
     <h2 id="dialogTitle"></h2>
     <div id="dialogBody"></div>
     <div class="actions" id="dialogActions"></div>
   </div>
 </div>


 <script>
 (()=>{
   "use strict";


   /* ------------------------------
      1) Constants / State
      ------------------------------ */
   const COUNTDOWN_SECONDS = 25;
   const STARTING_LIVES = 3;
   const TICK_MS = 100;


   let ANSWER_POOL = [];
   let GUESSES_SET = new Set();


   const state = {
     answerWord: "",
     bank: /** @type {{ch:string, used:boolean}[]} */([]),
     current: ["","","","",""],
     placedIndex: [null,null,null,null,null],
     lives: STARTING_LIVES,
     score: 0,
     runStartAt: 0,
     deadlineAt: 0,
     timerHandle: null,
     isAnimating: false,
     modalOpen: false,
   };


   /* ------------------------------
      2) DOM helpers
      ------------------------------ */
   const $ = (sel, root=document) => root.querySelector(sel);
   const app = $("#app");
   const livesEl = $("#lives");
   const scoreEl = $("#score");
   const timerRail = $("#timerRail");
   const timerFill = $("#timerFill");
   const srSeconds = $("#srSeconds");
   let lastSpokenSecs = null;
   const answerRow = $("#answerRow");
   const bankRow = $("#bank");
   const announcer = $("#announcer");
   const shuffleBtn = $("#shuffleBtn");
   const clearBtn = $("#clearBtn");
   const themeBtn = $("#themeBtn");


   const overlay = $("#overlay");
   const dialog = $("#dialog");
   const dialogTitle = $("#dialogTitle");
   const dialogBody = $("#dialogBody");
   const dialogActions = $("#dialogActions");
   (function preventZoomWebKit(){
  // We already use user-scalable=no and touch-action:none; just guard old pinch paths
  document.addEventListener('touchstart', (e) => {
    if (e.touches && e.touches.length > 1) e.preventDefault();
  }, { passive: false });
})();

    // Keep buttons square on rotation/resize (no viewport scaling logic)
    window.addEventListener('resize', syncControlHeights);
    window.addEventListener('orientationchange', syncControlHeights);


   /* ------------------------------
      4) Theme (persist localStorage)
      ------------------------------ */
   const THEME_KEY = 'jumbl-theme';
   function applyTheme(t){ document.documentElement.classList.toggle('dark', t === 'dark'); updateThemeIcon(); }
   function getSystemTheme(){ return matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'; }
   function initTheme(){ applyTheme(localStorage.getItem(THEME_KEY) || getSystemTheme()); }
   function toggleTheme(){
     const isDark = document.documentElement.classList.toggle('dark');
     localStorage.setItem(THEME_KEY, isDark ? 'dark' : 'light');
     updateThemeIcon();
   }
   function updateThemeIcon(){
     const isDark = document.documentElement.classList.contains('dark');
     const svg = $("#themeIcon");
     if(!svg) return;
     svg.setAttribute('viewBox','0 0 24 24');
     if(isDark){
       // filled crescent moon
       svg.innerHTML = '<path fill="currentColor" d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>';
     }else{
       // filled sun disc
       svg.innerHTML = '<circle cx="12" cy="12" r="10" fill="currentColor"/>';
     }
   }
   makeTap(themeBtn, toggleTheme);


   /* ------------------------------
      5) Utilities
      ------------------------------ */
   const randInt = n => Math.floor(Math.random()*n);
   function shuffleInPlace(arr){ for(let i=arr.length-1;i>0;i--){ const j = randInt(i+1); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
   function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
   const ANIM_CLASSES = ['shake','shake-soft','shake-tiny','jiggle','pop','pop-soft'];
   function play(el, cls){
     // remove any prior animation classes
     for(const c of ANIM_CLASSES) el.classList.remove(c);
     // restart next frame (avoids forced synchronous layout)
     requestAnimationFrame(()=>{
       el.classList.add(cls);
       el.addEventListener('animationend', ()=> el.classList.remove(cls), { once:true });
     });
   }
   function normalizeList(text){
     // strip BOM
     if(text.charCodeAt(0) === 0xFEFF){ text = text.slice(1); }
     const seen = new Set();
     const out = [];
     text.split(/\r?\n/).forEach(line=>{
       const s = line.trim().toUpperCase();
       if(/^[A-Z]{5}$/.test(s) && !seen.has(s)){ seen.add(s); out.push(s); }
     });
     return out;
   }


   function pickAnswer(){ return ANSWER_POOL[randInt(ANSWER_POOL.length)]; }


   function buildBankFrom(word){
     const arr = word.split("").map(ch=>({ ch, used:false }));
     return shuffleInPlace(arr);
   }


   function secondsSince(ts){ return Math.floor((Date.now()-ts)/1000); }
   function fmtMMSS(total){
     const m = Math.floor(total/60).toString().padStart(2,'0');
     const s = (total%60).toString().padStart(2,'0');
     return `${m}:${s}`;
   }


   /* ------------------------------
      6) Rendering
      ------------------------------ */
   function renderLives(){
     const frag = document.createDocumentFragment();
     for(let i=0;i<STARTING_LIVES;i++){
       const d = document.createElement('div');
       d.className = 'pip' + (i < state.lives ? '' : ' off');
       frag.appendChild(d);
     }
     livesEl.innerHTML = '';
     livesEl.appendChild(frag);
     livesEl.setAttribute('aria-label', `Lives: ${state.lives} of ${STARTING_LIVES}`);
   }


   function renderScore(){ scoreEl.textContent = `Score: ${state.score}`; }


   function renderTimer(){
     const now = performance.now();
     const remain = clamp(state.deadlineAt - now, 0, COUNTDOWN_SECONDS*1000);
     const ratio = remain / (COUNTDOWN_SECONDS*1000);
     timerFill.style.transform = `scaleX(${ratio})`; // right->left via transform-origin:left
     const secs = Math.ceil(remain/1000);
     timerRail.setAttribute('aria-valuenow', String(secs));
     // Speak at most once per second
     if (secs !== lastSpokenSecs) {
       srSeconds.textContent = `${secs} seconds remaining`;
       lastSpokenSecs = secs;
       // Subtle tick in the final 5 seconds
       if (secs <= 5 && secs > 0) { play(timerRail, 'shake-tiny'); }
      }
   }

   function renderAnswer(){
     const frag = document.createDocumentFragment();
     for(let i=0;i<5;i++){
       const v = state.current[i] || '';
       const d = document.createElement('div');
       d.className = 'tile' + (v ? '' : ' empty');
       d.textContent = v;
       d.setAttribute('aria-label', v ? `Slot ${i+1}: ${v}` : `Slot ${i+1}: empty`);
       frag.appendChild(d);
     }
     answerRow.innerHTML = '';
     answerRow.appendChild(frag);
   }


   function renderBank(){
     const frag = document.createDocumentFragment();
     state.bank.forEach((b, idx)=>{
       const btn = document.createElement('button');
       btn.className = 'btn-letter';
       btn.type = 'button';
       btn.textContent = b.ch;
       btn.disabled = b.used;
       btn.setAttribute('aria-pressed', b.used ? 'true' : 'false');
       btn.dataset.idx = String(idx);
       frag.appendChild(btn);
     });
     bankRow.innerHTML = '';
     bankRow.appendChild(frag);
     syncControlHeights();
   }


   function renderUI(){
     renderLives();
     renderScore();
     renderTimer();
     renderAnswer();
     renderBank();
   }


   function syncControlHeights(){
     const tile = bankRow.querySelector('.btn-letter');
     // Use width (square tiles) via offsetWidth to avoid transform-inflated rects
     const w = tile ? Math.round(tile.offsetWidth) : 0;
     if(w){
       const px = w + 'px';
       if (shuffleBtn.style.height !== px) shuffleBtn.style.height = px;
       if (clearBtn.style.height !== px)   clearBtn.style.height   = px;
     }
   }


   /* ------------------------------
      7) Timer control
      ------------------------------ */
   function startTimer(){
     stopTimer();
     state.deadlineAt = performance.now() + COUNTDOWN_SECONDS*1000;
     renderTimer();
     state.timerHandle = setInterval(()=>{
       renderTimer();
       if(performance.now() >= state.deadlineAt){ onTimeout(); }
     }, TICK_MS);
   }
   function stopTimer(){ if(state.timerHandle){ clearInterval(state.timerHandle); state.timerHandle = null; } }


   /* ------------------------------
      8) Core game flow
      ------------------------------ */
   function startRun(){
     app.classList.remove('pre');
     state.lives = STARTING_LIVES;
     state.score = 0;
     state.runStartAt = Date.now();
     nextWord(false);
   }


   function nextWord(increment){
     if(increment) state.score++;
     state.answerWord = pickAnswer();
     state.bank = buildBankFrom(state.answerWord);
     state.current = ["","","","",""];
     state.placedIndex = [null,null,null,null,null];
     state.isAnimating = false;
     renderUI();
     startTimer();
   }


   function onTimeout(){
     if(state.timerHandle === null) return; // already handled
     stopTimer();
     state.lives = Math.max(0, state.lives - 1);
     renderLives();
     // Reveal the correct word in answer row, shake, then advance or game over
     state.isAnimating = true;
     for(let i=0;i<5;i++){ state.current[i] = state.answerWord[i]; }
     renderAnswer();
     play(answerRow, 'shake');
     setTimeout(()=>{
       state.isAnimating = false;
       if(state.lives > 0){ nextWord(false); }
       else{ gameOver(); }
     }, 800);
   }


   function onLetterTap(bankIndex){
     if(state.isAnimating || state.modalOpen) return;
     const idx = state.placedIndex.indexOf(null); // next empty slot
     if(idx === -1) return; // full
     const b = state.bank[bankIndex];
     if(!b || b.used) return;
     b.used = true;
     state.current[idx] = b.ch;
     state.placedIndex[idx] = bankIndex;
     renderAnswer();
     renderBank();
     announcer.textContent = `Placed ${b.ch} in slot ${idx+1}`;
     // slot pop (soft) — only the tile we just filled
     const slotEl = answerRow.children[idx];
     if (slotEl) play(slotEl, 'pop-soft');
     autoSubmitIfFull();
   }


   function onShuffle(){
     if(state.isAnimating || state.modalOpen) return;
     // shuffle only unused letters
     const unused = [];
     const unusedIdx = [];
     state.bank.forEach((b, i)=>{ if(!b.used){ unused.push(b); unusedIdx.push(i); } });
     shuffleInPlace(unused);
     unusedIdx.forEach((slot, j)=>{ state.bank[slot] = unused[j]; });
     renderBank();
     play(bankRow, 'jiggle');
   }


   /* NEW — remove the rightmost placed letter and return it to the bank */
   function onBackspace(opts = { animate: true }){
     if (state.isAnimating || state.modalOpen) return;
     // find rightmost non-empty slot
     let i = -1;
     for (let j = 4; j >= 0; j--) { if (state.current[j]) { i = j; break; } }
     if (i === -1) return; // nothing to remove
     // restore bank letter that originally filled this slot
     const bi = state.placedIndex[i];
     if (bi !== null) { state.bank[bi].used = false; }
     // clear the slot
     state.current[i] = "";
     state.placedIndex[i] = null;
     // re-render UI
     renderAnswer();
     renderBank();
     // small feedback on the slot we edited
     if (opts.animate) {
       const slotEl = answerRow.children[i];
       if (slotEl) play(slotEl, 'shake-soft');
     }
     // a11y announce
     announcer.textContent = `Removed letter from slot ${i+1}`;
   }


   function onClearAll(opts = { animate: true, force: false }){
     // If a PointerEvent accidentally arrives, fall back to defaults
     if (opts && typeof opts === 'object' && ('type' in opts) && ('pointerId' in opts)) {
       opts = { animate: true, force: false };
     }
     // allow clearing during animations only when explicitly forced
     if (!opts.force && (state.isAnimating || state.modalOpen)) return;
     for (let i = 0; i < 5; i++) {
       const bi = state.placedIndex[i];
       if (bi !== null) { state.bank[bi].used = false; }
       state.current[i] = "";
       state.placedIndex[i] = null;
     }
     renderAnswer();
     renderBank();
     // animate clear only if requested (prevents double-shake on invalid)
     if (opts.animate){ play(answerRow, 'shake-soft'); }
   }


   function autoSubmitIfFull(){
     if(state.current.every(c=>c)){
       evaluateGuess(state.current.join(''));
     }
   }


   function evaluateGuess(guess){
     if (GUESSES_SET.has(guess)) {
       // Correct: soft-pop the bar + pop each tile in sync
       stopTimer();
       state.isAnimating = true;
       play(answerRow, 'pop-soft');
       [...answerRow.children].forEach(el => play(el, 'pop'));
       setTimeout(() => {
         state.isAnimating = false;
         nextWord(true);
       }, 600);
       return;
     }
     // Invalid: shake, then clear — robust on older iOS
     state.isAnimating = true;
     play(answerRow, 'shake');
     let cleared = false;
     const finish = () => {
       if (cleared) return;
       cleared = true;
       answerRow.removeEventListener('animationend', finish);
       onClearAll({ animate: false, force: true }); // <— force clears during animation
       state.isAnimating = false;
     };
     // Prefer animationend, but also guard with a timeout
     answerRow.addEventListener('animationend', finish, { once: true });
     setTimeout(finish, 320); // ~.22s shake + buffer
   }


   function gameOver(){
     stopTimer();
     showModal('Game over...',
       `<p><strong>${state.score}</strong> words in <strong>${fmtMMSS(secondsSince(state.runStartAt))}</strong></p>
       <p>say hi or report bugs...</p>
       <p>bbyjae-django-lab@proton.me</p>`,
       [ {label:'Again', action:()=>{ closeModal(); startRun(); }, isPrimary:true} ]
     );
   }


   /* ------------------------------
      9) Events — clicks & keyboard
      ------------------------------ */
   // Letter taps and keyboard keys: show press while held; commit on release
   bankRow.addEventListener('pointerdown', (e)=>{
     const t = e.target;
     if(!(t instanceof HTMLElement)) return;
     if(!t.classList.contains('btn-letter')) return;
     if (t.disabled) return;
     t.classList.add('press');
     // capture so we always get the matching pointerup/cancel
     if (typeof t.setPointerCapture === 'function') { try { t.setPointerCapture(e.pointerId); } catch {} }
   });


   bankRow.addEventListener('pointerup', (e)=>{
     const t = e.target;
     if(!(t instanceof HTMLElement)) return;
     if(!t.classList.contains('btn-letter')) return;
     t.classList.remove('press');
     if (t.disabled) return; // might have been disabled mid-press
     const idx = Number(t.dataset.idx);
     onLetterTap(idx);
   });


   bankRow.addEventListener('pointercancel', (e)=>{
     const t = e.target;
     if(t instanceof HTMLElement && t.classList.contains('btn-letter')){ t.classList.remove('press'); }
   });


   bankRow.addEventListener('pointerleave', (e)=>{
     const t = e.target;
     if(t instanceof HTMLElement && t.classList.contains('btn-letter')){ t.classList.remove('press'); }
   });


   // Buttons (taps and keyboard keys): stay "pressed" while held; pop back on pointerup, then run action
   function makeTap(btn, handler){
     if(!btn) return;
     btn.addEventListener('pointerdown', () => btn.classList.add('press'));
     btn.addEventListener('pointerup', () => { btn.classList.remove('press'); handler(); });
     btn.addEventListener('pointercancel', () => btn.classList.remove('press'));
     btn.addEventListener('pointerleave', () => btn.classList.remove('press'));
   }


   makeTap(shuffleBtn, onShuffle);
   makeTap(clearBtn, () => onClearAll({ animate: true }));
    // Answer bar: show imprint while held; remove exactly one letter on real release
(function wireAnswerBarTap(){
  let activePid = null; // which pointer we own

  function cleanup(){
    activePid = null;
    answerRow.classList.remove('press-row');
  }

  function down(e){
    if (state.isAnimating || state.modalOpen || activePid !== null) return;
    activePid = e.pointerId ?? 1;
    answerRow.classList.add('press-row');
    // keep receiving events even if the finger drifts off the row
    if (answerRow.setPointerCapture) {
      try { answerRow.setPointerCapture(activePid); } catch {}
    }
  }

  function up(e){
    if (e.pointerId !== activePid) { cleanup(); return; } // ignore stray ups
    cleanup();
    if (state.isAnimating || state.modalOpen) return;
    onBackspace({ animate: true });
  }

  function cancel(){
    // never commit on cancel/leave; just clear the imprint
    cleanup();
  }

  answerRow.addEventListener('pointerdown', down);
  answerRow.addEventListener('pointerup', up);
  answerRow.addEventListener('pointercancel', cancel);
  // NOTE: do not commit on leave anymore (prevents double removals on tiny drift)
  answerRow.addEventListener('pointerleave', cancel);
})();

   // Keyboard-to-UI press tracking (Space/Backspace/letters)
   const keyHold = new Map(); // key -> { type, idx?, el }


   document.addEventListener('keydown', (e)=>{
     // visuals only; actions commit on keyup
     if(state.modalOpen || state.isAnimating) return;
     if(e.repeat) return; // ignore auto-repeats
     const k = e.key;
     // Space ↔ Shuffle
     if(k === ' ' || k === 'Spacebar' || k === 'Space'){
       e.preventDefault();
       shuffleBtn.classList.add('press');
       keyHold.set('Space', { type:'shuffle', el: shuffleBtn });
       return;
     }
     // Backspace/Delete ↔ Clear
     if(k === 'Backspace' || k === 'Delete'){
       e.preventDefault();
       clearBtn.classList.add('press');
       keyHold.set('Clear', { type:'clear', el: clearBtn });
       return;
     }
     // A–Z keys map to the first unused matching bank letter
     if(k.length === 1){
       const ch = k.toUpperCase();
       if(ch < 'A' || ch > 'Z') return;
       const i = state.bank.findIndex(b => !b.used && b.ch === ch);
       if(i !== -1){
         const btn = bankRow.querySelectorAll('.btn-letter')[i];
         if(btn){ btn.classList.add('press'); keyHold.set(ch, { type:'letter', idx:i, el: btn }); }
       }
     }
   }, true);


   document.addEventListener('keyup', (e)=>{
     const k = e.key;
     let hold = null;
     if(k === ' ' || k === 'Spacebar' || k === 'Space') hold = keyHold.get('Space');
     else if(k === 'Backspace' || k === 'Delete') hold = keyHold.get('Clear');
     else if(k.length === 1) hold = keyHold.get(k.toUpperCase());
     if(!hold) return;
     // Always clear the visual press
     if(hold.el && hold.el.classList) hold.el.classList.remove('press');
     keyHold.delete(k === ' ' || k === 'Spacebar' || k === 'Space' ? 'Space' : (k === 'Backspace' || k === 'Delete' ? 'Clear' : k.toUpperCase()));
     // If a modal opened or animation started, abort action
     if(state.modalOpen || state.isAnimating) return;
     if(hold.type === 'shuffle'){ onShuffle(); return; }
     if(hold.type === 'clear'){ onClearAll({ animate: true }); return; }
     if(hold.type === 'letter'){ onLetterTap(hold.idx); }
   }, true);


   window.addEventListener('blur', ()=>{
     // Remove any stuck .press when focus leaves the window
     for(const h of keyHold.values()){ if(h.el && h.el.classList) h.el.classList.remove('press'); }
     keyHold.clear();
   });


   /* ------------------------------
      10) Modals (reusable) + focus mgmt
      ------------------------------ */
   let restoreFocusEl = null;
   // NEW — modal keyboard handling (Enter/Space press + commit)
   let modalHeldBtn = null;
   function onModalKeyDown(e){
     if(e.key !== 'Enter' && e.key !== ' ') return;
     const t = document.activeElement;
     if(!(t instanceof HTMLElement)) return;
     if(!dialog.contains(t)) return;
     if(t.tagName !== 'BUTTON') return;
     e.preventDefault(); // prevent scrolling/submit defaults
     t.classList.add('press');
     modalHeldBtn = t;
   }
   function onModalKeyUp(e){
     if(e.key !== 'Enter' && e.key !== ' ') return;
     const t = (modalHeldBtn && dialog.contains(modalHeldBtn)) ? modalHeldBtn : document.activeElement;
     modalHeldBtn = null;
     if(!(t instanceof HTMLElement)) return;
     if(!dialog.contains(t)) return;
     if(t.tagName !== 'BUTTON') return;
     t.classList.remove('press');
     // Prefer the action we attached; fall back to click() if present.
     if (typeof t.__action === 'function') { t.__action(); }
     else if (typeof t.click === 'function') { t.click(); }
   }


   function showModal(title, bodyHTML, actions){
     state.modalOpen = true;
     app.classList.add('masked');
     overlay.setAttribute('aria-hidden','false');
     dialog.setAttribute('aria-hidden','false');
     dialogTitle.textContent = title;
     dialogBody.innerHTML = bodyHTML;
     dialogActions.innerHTML = '';
     actions.forEach(a=>{
       const b = document.createElement('button');
       b.type = 'button';
       b.textContent = a.label;
       if(a.isPrimary) b.autofocus = true;
       makeTap(b, a.action);
       b.__action = a.action;
       dialogActions.appendChild(b);
     });
     restoreFocusEl = document.activeElement;
     const firstBtn = dialogActions.querySelector('button') || dialog.querySelector('button');
     if(firstBtn) firstBtn.focus();
     // basic trap
     dialog.addEventListener('keydown', trapTab);
     document.addEventListener('keydown', escClose);
     app.setAttribute('aria-hidden','true');
     dialog.addEventListener('keydown', onModalKeyDown, true);
     document.addEventListener('keyup', onModalKeyUp, true);
   }


   function closeModal(){
     state.modalOpen = false;
     app.classList.remove('masked');
     overlay.setAttribute('aria-hidden','true');
     dialog.setAttribute('aria-hidden','true');
     dialog.removeEventListener('keydown', trapTab);
     document.removeEventListener('keydown', escClose);
     app.removeAttribute('aria-hidden');
     dialog.removeEventListener('keydown', onModalKeyDown, true);
     document.removeEventListener('keyup', onModalKeyUp, true);
     if(restoreFocusEl && restoreFocusEl.focus) restoreFocusEl.focus();
   }


   function trapTab(e){
     if(e.key !== 'Tab') return;
     const focusables = dialog.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
     if(!focusables.length) return;
     const first = focusables[0]; const last = focusables[focusables.length-1];
     if(e.shiftKey && document.activeElement === first){ e.preventDefault(); last.focus(); }
     else if(!e.shiftKey && document.activeElement === last){ e.preventDefault(); first.focus(); }
   }
   function escClose(e){ if(e.key === 'Escape'){ closeModal(); } }


   function showLoading(msg, canRetry){
     const retryBtn = { label:'Retry', action:()=>{ closeModal(); loadWordLists(); }, isPrimary:true };
     showModal('Loading word lists…', `<p>${msg}</p>`, canRetry ? [retryBtn] : []);
   }


   function showIntro(){
     const body = `
       <p>5 letters. 25 seconds. 3 lives.</p>
       <p></p>
       <p>Highest score wins.</p>`;
     showModal('Rules...', body, [ {label:'Play', action:()=>{ closeModal(); startRun(); }, isPrimary:true} ]);
   }


   /* ------------------------------
      11) Data loading & validation
      ------------------------------ */
   async function loadWordLists(){
     showLoading('Fetching…', false);
     try{
       const ctrl = new AbortController();
       const opts = { cache: 'no-store', signal: ctrl.signal };
       const [aRes, gRes] = await Promise.all([
         fetch('answers.txt', opts),
         fetch('guesses.txt', opts)
       ]);
       if(!aRes.ok || !gRes.ok) throw new Error('Network error while fetching lists.');
       const [aText, gText] = await Promise.all([aRes.text(), gRes.text()]);
       const answers = normalizeList(aText);
       const guesses = normalizeList(gText);
       if(!answers.length || !guesses.length) throw new Error('One or both files are empty after parsing.');
       // Build sets and validate subset (ensure answers ⊆ guesses)
       const gSet = new Set(guesses);
       const missing = answers.filter(w => !gSet.has(w));
       if(missing.length){
         showModal(
           'Error in word lists',
           `<p>All answers must also appear in <code>guesses.txt</code>.</p><p>Missing ${missing.length} entries. Example: <code>${missing.slice(0,5).join(', ')}</code></p>`,
           [ {label:'Retry', action:()=>{ closeModal(); loadWordLists(); }, isPrimary:true} ]
         );
         return;
       }
       ANSWER_POOL = answers;
       GUESSES_SET = gSet;
       closeModal();
       // After lists load, show Intro
       showIntro();
     }catch(err){
       console.error(err);
       showLoading('Error loading word lists. Please try again.', true);
     }
   }


   /* ------------------------------
      12) Boot
      ------------------------------ */
   initTheme();
   loadWordLists();
 })();
 </script>
</body>
</html>
